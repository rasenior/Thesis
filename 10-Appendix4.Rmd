```{r knitr-setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = FALSE,message = FALSE,error = FALSE, warning = FALSE, 
                      fig.width = 16.6/2.54, fig.height = 9/2.54, dpi = 800, 
                      fig.path = "./output/", fig.align='center', fig.pos = 'H')
```

```{r}

library(raster)
library(rgdal)
library(rgeos)
library(knitr)
library(ggplot2)
library(ggrepel)
library(scales)
library(dplyr)
library(cowplot)
library(xtable)
library(viridis)
library(extrafont)

source("../../Programming/R/functions/geom_holygon.R")

# Plotting parameters
text_size <- 6
title_size <- 8
lab_size <- 7

# Colourblind-friendly palette
cbpal1 <- viridis(4, option = "D")
cbpal2 <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#CC79A7", "#D55E00","#0072B2")

# Function for extracting legend
g_legend<-function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    return(legend)}

# Significance val
get_signif <- function(p_val){
    signif_level <- 
        ifelse(p_val >0.05, paste("= ", signif(p_val, 3), sep = ""),
               ifelse(p_val <= 0.05 & p_val >0.01, "< 0.05",
                      ifelse(p_val <= 0.01 & p_val >0.001, "< 0.01", 
                             "< 0.001")))
    return(signif_level)
}

relevel_df <- function(df){
    # Relevel dataset name
    df[,"df_name"] <- 
        factor(df[,"df_name"], 
               levels = c(c("full_rcp26",
                            "full_rcp85"),
                          c("plantations-w_10_sep_2", 
                            "plantations-wo_10_sep_2"),
                          paste("full_area_", 
                                c(1,5,10,25,100), 
                                "_sep_2", 
                                sep = "")),
               labels = c(c("RCP2.6", 
                            "RCP8.5"),
                          c("With plantations",
                            "Without plantations"),
                          paste(c(1,5,10,25,100), 
                                " km", 
                                "\U00B2", sep = "")))
    # Relevel realm
    if("realm" %in% names(df)){
        df[,"realm"] <- factor(df[,"realm"],
                               levels = c("Neotropics",
                                          "Afrotropics",
                                          "Indomalaya",
                                          "Australasia",
                                          "Oceania")) 
        df <- arrange(df, df_name, realm)
    }else df <- arrange(df, df_name)
    
    return(df)
}

sort_results <- function(dat, RV, Df, stat, stat_val,P, 
                         fig_refs, results = "main_results"){
    dat <-
        do.call("rbind",
                lapply(dat,
                       function(x) rbind(x[[results]])))
    row.names(dat) <- NULL
    dat <- 
        data.frame(dat) %>% 
        mutate(RV = RV,
               Df = Df,
               EV = dropped_EV,
               stat = stat,
               stat_val = dat[,stat_val],
               P = dat[,P],
               p_val = get_signif(P),
               fig_ref = fig_refs) %>%
        filter(!(is.na(p_val))) %>% 
        dplyr::select(df_name, RV, EV, Df, stat, stat_val, P, p_val, fig_ref) %>% 
        mutate(ref = paste(stat, " = ", signif(stat_val,3), ", ",
                           "P ", p_val, 
                           "; ", fig_ref,
                           sep = "")) %>% 
        relevel_df()
    return(dat)
}
```

```{r raw-dat, include = FALSE}
# Identify all the subdirs
paths <- c(
    list.files("data/ch5/rcps", 
               recursive = FALSE, 
               pattern = "rcp", 
               full.names = TRUE),
    list.files("data/ch5/patch_params", 
               recursive = FALSE, 
               pattern = "^area_", 
               full.names = TRUE),
    list.files("data/ch5/plantations", 
               recursive = FALSE, 
               pattern = "^plantations", 
               full.names = TRUE))

# Climate connectivity ---------------------------------------------------------
region_cc <- 
    # Define paths
    file.path(paths, "region_cc.Rds") %>% 
    # Read in
    lapply(function(x) as.data.frame(readRDS(x))) %>% 
    lapply(function(x) mutate(x,region_area_log = log(region_area)))

# Bind for plotting
region_cc <- do.call("rbind", region_cc) %>% 
    relevel_df()
# Separate for diff sections
region_cc_som1 <- region_cc[grep("plantations",region_cc$df_name),]
region_cc_som2 <- region_cc[grep("km",region_cc$df_name),]
region_cc_som3 <- region_cc[grep("RCP",region_cc$df_name),]
region_cc_vuln <- filter(region_cc_som3, df_name == "RCP8.5")
rm(region_cc)

# Climate connectivity change --------------------------------------------------
region_ccc <- 
    # Define paths
    file.path(paths, "region_ccc.Rds") %>% 
    # Read in
    lapply(function(x) as.data.frame(readRDS(x))) %>% 
    lapply(function(x){
        mutate(x, 
               region_area_log = log(region_area),
               prop_decrease_cc = area_decrease_cc / sum_patch_area,
               area_nondecrease_cc = area_increase_cc + area_same_cc, 
               tc_2000_log = log(tc_2000),
               tc_loss_log1p = log1p(loss))
    })
# Bind for plotting
region_ccc <- 
    do.call("rbind", region_ccc) %>% 
    relevel_df()
# Separate for diff sections
region_ccc_som1 <- region_ccc[grep("plantations",region_ccc$df_name),]
region_ccc_som2 <- region_ccc[grep("km",region_ccc$df_name),]
region_ccc_som3 <- region_ccc[grep("RCP",region_ccc$df_name),]
rm(region_ccc)

# Data for worked example
load("data/ch5/som_text3_dat.rdata")
```

```{r map-overlays, include = FALSE}

# Boundary
boundary <- readRDS("data/ch5/boundary.Rds")

# Patches
patches <- 
    readRDS("data/ch5/rcps/rcp85/patches.Rds") %>% 
    na.omit() %>% 
    filter(year == "2012")

# Ccc polygons
ccc_polys <- 
    readRDS("data/ch5/rcps/rcp85/ccc_polys.Rds") %>% 
    na.omit() %>% 
    mutate(year = "2012 - 2000")

# Vulnerability overlay
vuln <- readRDS("data/ch5/vuln.Rds")

# Vulnerability mask
vuln_mask <- 
    readRDS("data/ch5/vuln_mask.Rds")

# KBA overlay
kba <- readRDS("data/ch5/kba.Rds")

# KBA mask
kba_mask <- readRDS("data/ch5/kba_mask.Rds")

# Full region cc df
region_cc <- readRDS("data/ch5/rcps/rcp85/region_cc.Rds")

# Order Oceania regions by area & assign name
oceania <- 
    filter(patches,
           realm == "Oceania",
           !(duplicated(region)))

oceania <-
    region_cc[match(oceania$region, region_cc$region),] %>%
    dplyr::select(region, region_area) %>% 
    arrange(desc(region_area)) %>% 
    mutate(region_name = c("Viti Levu (Fiji)",
                           "Hawai'i (Hawaii)",
                           "Vanua Levu (Fiji)",
                           "O'ahu (Hawaii)",
                           "Kauai (Hawaii)",
                           "Kadavu Island (Fiji)",
                           "Taveuni Island (Fiji)",
                           "Babeldaob (Palau)"))

#   region region_area
# 1 p25236  10651.6281 = Viti Levu (Fiji)
# 2 p10780  10431.1066 = Hawai'i (Hawaii)
# 3 p22626   5689.2545 = Vanua Levu (Fiji)
# 4  p3617   1556.0912 = O'ahu (Hawaii)
# 5 p21905   1438.5133 = Kauai (Hawaii)
# 6  p2145    439.6505 = Kadavu Island (Fiji)
# 7 p15596    435.9987 = Taveuni Island (Fiji)
# 8 p21477    365.1751 = Babeldaob (Palau)

# Add region name to polygon layers
boundary$region_name <- 
    oceania$region_name[match(boundary$id, oceania$region)]
vuln_mask$region_name <- 
    oceania$region_name[match(vuln_mask$id, oceania$region)]
kba$region_name <- 
    oceania$region_name[match(kba$id, oceania$region)]
kba_mask$region_name <- 
    oceania$region_name[match(kba_mask$id, oceania$region)]
patches$region_name <- 
    oceania$region_name[match(patches$region, oceania$region)]
ccc_polys$region_name <- 
    oceania$region_name[match(ccc_polys$region, oceania$region)]

# Remove regions < 300 km^2
boundary <-
    filter(boundary,
           region_area >= 300,
           # Also remove non-tropical realms
           realm %in% c("Neotropics",
                        "Afrotropics",
                        "Indomalaya",
                        "Australasia",
                        "Oceania"),
           # Also reduce to regions that actually have connectivity data
           id %in% patches$region)
vuln_mask <-
    filter(vuln_mask,
           # Also reduce to regions that actually have connectivity data
           id %in% patches$region)
kba <-
    filter(kba,
           # Also reduce to regions that actually have connectivity data
           id %in% patches$region)
kba_mask <-
    filter(kba_mask,
           # Also reduce to regions that actually have connectivity data
           id %in% patches$region)
patches <- 
    patches %>% 
    filter(region_area >= 300,
           !(is.na(realm)))
ccc_polys <- 
    ccc_polys %>% 
    filter(region_area >= 300,
           !(is.na(realm)))

# Define function to adjust lat/long for Oceania
adj_oceania <- function(df, 
                        hawaii_adj = list(),
                        palau_adj = list()
){
    # Adjust Hawaii
    df[grepl("Hawaii", df[,"region_name"]), "long"] <-
        df[grepl("Hawaii", df[,"region_name"]), "long"] + hawaii_adj$long
    df[grepl("Hawaii", df[,"region_name"]), "lat"] <-
        df[grepl("Hawaii", df[,"region_name"]), "lat"] + hawaii_adj$lat
    
    # Adjust Palau
    df[grepl("Palau", df[,"region_name"]), "long"] <-
        df[grepl("Palau", df[,"region_name"]), "long"] + palau_adj$long
    df[grepl("Palau", df[,"region_name"]), "lat"] <-
        df[grepl("Palau", df[,"region_name"]), "lat"] + palau_adj$lat
    
    # Return
    return(df)
}

# Shift Hawaii & Palau polygons
boundary <- 
    adj_oceania(df = boundary,
                # Max long (180 degrees) plus extra adjustment
                hawaii_adj = (list(long = 20037507.067162 + 17900000, 
                                   lat = - 3700000)),
                palau_adj = (list(long = 4900000,
                                  lat = - 2300000)))
vuln_mask <- 
    adj_oceania(df = vuln_mask,
                # Max long (180 degrees) plus extra adjustment
                hawaii_adj = (list(long = 20037507.067162 + 17900000, 
                                   lat = - 3700000)),
                palau_adj = (list(long = 4900000,
                                  lat = - 2300000)))
kba <- 
    adj_oceania(df = kba,
                # Max long (180 degrees) plus extra adjustment
                hawaii_adj = (list(long = 20037507.067162 + 17900000, 
                                   lat = - 3700000)),
                palau_adj = (list(long = 4900000,
                                  lat = - 2300000)))
kba_mask <- 
    adj_oceania(df = kba_mask,
                # Max long (180 degrees) plus extra adjustment
                hawaii_adj = (list(long = 20037507.067162 + 17900000, 
                                   lat = - 3700000)),
                palau_adj = (list(long = 4900000,
                                  lat = - 2300000)))
patches <- 
    adj_oceania(df = patches,
                # Max long (180 degrees) plus extra adjustment
                hawaii_adj = (list(long = 20037507.067162 + 17900000, 
                                   lat = - 3700000)),
                palau_adj = (list(long = 4900000,
                                  lat = - 2300000)))
ccc_polys <- 
    adj_oceania(df = ccc_polys,
                # Max long (180 degrees) plus extra adjustment
                hawaii_adj = (list(long = 20037507.067162 + 17900000, 
                                   lat = - 3700000)),
                palau_adj = (list(long = 4900000,
                                  lat = - 2300000)))

# Define extras for Oceania facet
oceania_labs <- 
    data.frame(realm = "Oceania",
               lab = c("Palau",
                       "Hawaii",
                       "Fiji"),
               long = c(19850000,
                        20450000,
                        19850000),
               lat = c(rep(-1600000,2),
                       -1730000),
               vline = 20090000,
               hline = -1680000)
```

```{r median-cc-dat, include = FALSE}

# With/without plantations -----------------------------------------------------
load("data/ch5/models/plantations/median_cc.Rdata")
median_cc_dat_som1 <- median_cc_dat
median_cc_results_som1 <- median_cc_results
rm(median_cc_dat, median_cc_results)

# Sort results
median_cc_results_som1 <- 
    sort_results(dat = median_cc_results_som1, 
                 RV = "median_cc", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-4}a")


# Sort predicted values
median_cc_dat_som1 <-
    median_cc_dat_som1 %>% 
    relevel_df() %>% 
    mutate(median_cc = signif(median_cc,3))

# Different patch parameters  --------------------------------------------------
load("data/ch5/models/patch_params/median_cc.Rdata")
median_cc_dat_som2 <- median_cc_dat
median_cc_results_som2 <- median_cc_results
rm(median_cc_dat, median_cc_results)

# Interaction results
median_cc_interaction_som2 <- 
    sort_results(dat = median_cc_results_som2, 
                 RV = "median_cc", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-6}a", 
                 results = "interaction_results")

# Main results
median_cc_results_som2 <- 
    sort_results(dat = median_cc_results_som2, 
                 RV = "median_cc", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-6}a")

# Sort predicted values
median_cc_dat_som2 <-
    median_cc_dat_som2 %>% 
    relevel_df() %>% 
    mutate(median_cc = signif(median_cc,3)) %>% 
    # Rank by median cc within dataset > realm > year
    arrange(df_name, realm, year, median_cc) %>% 
    group_by(df_name, year) %>% 
    mutate(rank = rank(median_cc, ties.method = "first"))

# Different RCPs  --------------------------------------------------
load("data/ch5/models/rcps/median_cc.Rdata")
median_cc_dat_som3 <- median_cc_dat
median_cc_results_som3 <- median_cc_results
rm(median_cc_dat, median_cc_results)

# Interaction results
median_cc_interaction_som3 <- 
    sort_results(dat = median_cc_results_som3, 
                 RV = "median_cc", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-8}a", 
                 results = "interaction_results")

# Main results
median_cc_results_som3 <- 
    sort_results(dat = median_cc_results_som3, 
                 RV = "median_cc", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-8}a")

# Sort predicted values
median_cc_dat_som3 <-
    median_cc_dat_som3 %>% 
    relevel_df() %>% 
    mutate(median_cc = signif(median_cc,3)) %>% 
    # Rank by median cc within dataset > realm > year
    arrange(df_name, realm, year, median_cc) %>% 
    group_by(df_name, year) %>% 
    mutate(rank = rank(median_cc, ties.method = "first"))
```

```{r prop_fail_dat, include = FALSE}

# With/without plantations -----------------------------------------------------
load("data/ch5/models/plantations/prop_fail.Rdata")
prop_fail_dat_som1 <- prop_fail_dat
prop_fail_results_som1 <- prop_fail_results
rm(prop_fail_dat, prop_fail_results)

# Sort results
prop_fail_results_som1 <- 
    sort_results(dat = prop_fail_results_som1, 
                 RV = "prop_fail", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-4}b")

# Sort predicted values
prop_fail_dat_som1 <-
    prop_fail_dat_som1 %>% 
    relevel_df()

# Different patch parameters----------------------------------------------------
load("data/ch5/models/patch_params/prop_fail.Rdata")
prop_fail_dat_som2 <- prop_fail_dat
prop_fail_results_som2 <- prop_fail_results
rm(prop_fail_dat, prop_fail_results)

# Interaction results
prop_fail_interaction_som2 <- 
    sort_results(dat = prop_fail_results_som2, 
                 RV = "prop_fail", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-6}b",
                 results = "interaction_results")

# Main results
prop_fail_results_som2 <- 
    sort_results(dat = prop_fail_results_som2, 
                 RV = "prop_fail", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-6}b")

# Sort predicted values
prop_fail_dat_som2 <-
    prop_fail_dat_som2 %>% 
    relevel_df() %>%
    # Rank by median cc within dataset > realm > year
    arrange(df_name, realm, year, prop_fail) %>% 
    group_by(df_name, year) %>% 
    mutate(rank = rank(-prop_fail, ties.method = "first"))

# Different RCPs ----------------------------------------------------
load("data/ch5/models/rcps/prop_fail.Rdata")
prop_fail_dat_som3 <- prop_fail_dat
prop_fail_results_som3 <- prop_fail_results
rm(prop_fail_dat, prop_fail_results)

# Interaction results
prop_fail_interaction_som3 <- 
    sort_results(dat = prop_fail_results_som3, 
                 RV = "prop_fail", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-8}b",
                 results = "interaction_results")

# Main results
prop_fail_results_som3 <- 
    sort_results(dat = prop_fail_results_som3, 
                 RV = "prop_fail", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-8}b")

# Sort predicted values
prop_fail_dat_som3 <-
    prop_fail_dat_som3 %>% 
    relevel_df() %>% 
    # Rank by median cc within dataset > realm > year
    arrange(df_name, realm, year, prop_fail) %>% 
    group_by(df_name, year) %>% 
    mutate(rank = rank(-prop_fail, ties.method = "first"))
```

```{r cc-loss-dat, include = FALSE}

# With/without plantations -----------------------------------------------------
load("data/ch5/models/plantations/cc_loss.Rdata")
cc_loss_tc_loss_som1 <- cc_loss_dat
cc_loss_results_som1 <- cc_loss_results
rm(cc_loss_results, cc_loss_dat)

# Sort results
cc_loss_results_som1 <- 
    sort_results(dat = cc_loss_results_som1, 
                 RV = "cc_loss", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-5}")

# Sort predicted values
cc_loss_tc_loss_som1 <-
    cc_loss_tc_loss_som1 %>% 
    relevel_df() %>% 
    mutate(prop_decrease_cc = signif(prop_decrease_cc,3))

# Different patch parameters ---------------------------------------------------
load("data/ch5/models/patch_params/cc_loss.Rdata")
cc_loss_tc_loss_som2 <- cc_loss_dat
cc_loss_results_som2 <- cc_loss_results
rm(cc_loss_results, cc_loss_dat)

# Sort results
cc_loss_results_som2 <- 
    sort_results(dat = cc_loss_results_som2, 
                 RV = "cc_loss", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-7}")

# Sort predicted values
cc_loss_tc_loss_som2 <-
    cc_loss_tc_loss_som2 %>% 
    relevel_df() %>% 
    mutate(prop_decrease_cc = signif(prop_decrease_cc,3))

# Different RCPs ---------------------------------------------------
load("data/ch5/models/rcps/cc_loss.Rdata")
cc_loss_tc_loss_som3 <- cc_loss_dat
cc_loss_results_som3 <- cc_loss_results
rm(cc_loss_results, cc_loss_dat)

# Sort results
cc_loss_results_som3 <- 
    sort_results(dat = cc_loss_results_som3, 
                 RV = "cc_loss", 
                 Df = "Df",
                 stat =  "F",
                 stat_val = "F",
                 P =  "Pr(>F)",
                 fig_refs = "\\autoref{fig:fig-D-9}")

# Sort predicted values
cc_loss_tc_loss_som3 <-
    cc_loss_tc_loss_som3 %>% 
    relevel_df() %>% 
    mutate(prop_decrease_cc = signif(prop_decrease_cc,3))
```

```{r write, include = FALSE, eval = FALSE}
# Write SOM results for inclusion in main text
save(median_cc_dat_som1, median_cc_dat_som2, median_cc_dat_som3,
     median_cc_interaction_som2, median_cc_interaction_som3,
     median_cc_results_som1, median_cc_results_som2, median_cc_results_som3,
     prop_fail_dat_som1, prop_fail_dat_som2, prop_fail_dat_som3,
     prop_fail_interaction_som2, prop_fail_interaction_som3,
     prop_fail_results_som1, prop_fail_results_som2, prop_fail_results_som3,
     cc_loss_results_som1, cc_loss_results_som2, cc_loss_results_som3,
     cc_loss_tc_loss_som1, cc_loss_tc_loss_som2, cc_loss_tc_loss_som3, 
     file = "data/ch5/som_dat.Rdata")
```


# Supporting information for Chapter 5

## Supplementary analyses for different patch parameters {#text-D-1}

### Methods

Following @mcguire_achieving_2016 we excluded forest patches less than 10 km^2^. This was based on the assumption that excessively small patches are incapable of sustaining populations for long enough to enable range shifts through differential fitness at the leading and trailing edge of a species' range. However, the critical patch size to enable such demographic processes to occur will depend on the species in question, and indeed some species may shift their ranges via within-generation movement of migrating individuals. We tested the influence of minimum patch size by repeating the analyses for patch sizes of 1, 5, 10, 25 and 100 km^2^. Note that a minimum size of 1 km^2^ corresponds to no exclusions, since this is the resolution of the layers used. To speed up iteration over the different parameters we used a subset of the main data, which excluded land masses less than 10 km^2^ and those with a temperature range less than the predicted temperature change under climate warming, since range shifts are unlikely to be sufficient responses to climate change in these land masses.

### Results and Discussion

Current climate connectivity was captured by median climate connectivity in 2012, and the proportion of forested area that failed to achieve successful climate connectivity (&ge; 0) in 2012. Median climate connectivity differed by realm for all patch sizes assessed (P < 0.001; \autoref{fig:fig-D-6}a), and was below zero in all cases except where minimum patch size was 1 km^2^. This suggests that for species capable of surviving and reproducing in patch sizes of 1 km^2^ or less, current forest cover is sufficiently well-connected along climate gradients that these species should, on average, be able to shift their range within existing forest cover to avoid climate warming. For species requiring a larger critical patch size, tropical forest cover in all biogeographic realms was, on average, insufficient to facilitate such range shifts. For all patch sizes, median climate connectivity was generally lowest in the Neotropics, followed by the Afrotropics, Indomalaya, Australasia and Oceania (precise ranking depended on the minimum patch size applied; \autoref{fig:fig-D-6}a).

The percentage of forest area with unsuccessful climate connectivity (< 0) in the year 2012 varied by biogeographic realm for all minimum patch sizes (P < 0.001). Precise ranking varied by minimum patch size (\autoref{fig:fig-D-6}b), but generally the Afrotropics and Indomalaya had the highest proportion of forest failing to connect to future climate analogues, while the Neotropics and Australasia had the lowest. We suggest that low average values of climate connectivity in the Neotropics are somewhat compensated for by the large size of forest patches that do achieve successful climate connectivity. Although the proportion of successfully connected tropical forest was generally more than half of total forest area, a substantial portion of forest failed to achieve climate connectivity and the situation was worse for a larger minimum patch size and when including all land masses in the tropics (see [Chapter 5](#ch5)).

(ref:cap-D-6) Climate connectivity in the year 2000 (green) and 2012 (purple), for different values of minimum patch size (rows). Panel (a) shows results for median climate connectivity, with the dashed line indicating zero climate connectivity, at and above which successful climate connectivity is achieved. Panel (b) shows results for the proportion of total forested area that fails to achieve successful climate connectivity. Hollow circles are model-predicted values with 95% confidence intervals. The small number in the centre indicates rank: 1 corresponds to the realm and dataset with the worst climate connectivity, through to 5 for the best. Raw data are plotted in the background as semi-transparent, filled points. Confidence intervals in panel (b) are plotted with dotted lines where they extend beyond 0 or 100%. 

```{r fig-D-6, fig.cap= "(ref:cap-D-6)", fig.height= 21/2.54}
linewidth <- 0.3
errorwidth <- 0.2

pd6a <-
    ggplot(data = median_cc_dat_som2, 
           aes(x = year,
               y = median_cc)) +
    geom_hline(yintercept = 0, 
               linetype = "dashed",
               size = 0.5) +
    geom_blank() +
    geom_rect(aes(xmin = -Inf,
                  xmax = Inf,
                  ymin = -Inf,
                  ymax = 0,
                  colour = NULL),
              fill = cbpal2[5],
              alpha = 0.2) +
    geom_rect(aes(xmin = -Inf,
                  xmax = Inf,
                  ymin = 0,
                  ymax = Inf,
                  colour = NULL),
              fill = cbpal2[7],
              alpha = 0.1) +
    geom_jitter(data = region_cc_som2,
                aes(x = year,
                    y = median_cc,
                    colour = year,
                    fill = year),
                alpha = 0.3,
                shape = 21,
                size= 0.5) +
    geom_errorbar(aes(ymin = lwr, 
                      ymax = upr),
                  width = errorwidth,
                  size = linewidth,
                  position = position_dodge(width = 0.5)) +
    geom_point(aes(colour = year),
               fill = "white",
               position = position_dodge(width = 0.5),
               shape = 21,
               size = 2) +
    geom_text(aes(label = rank,
                  colour = year),
              position = position_dodge(width = 0.5),
              size = 1.5,
              show.legend = FALSE) +
    facet_grid(df_name ~ realm, 
               switch = "x",
               scales = "free") +
    ylab(paste("Median climate connectivity (", "\U00B0","C)",sep="")) +
    theme_bw() +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_text(size = title_size),
          axis.text.y = element_text(size = text_size),
          strip.text = element_text(size = lab_size),
          panel.spacing = unit(0, units = "cm"),
          panel.grid = element_blank()) +
    scale_colour_manual(values = cbpal1[c(3,1)]) +
    scale_fill_manual(values = cbpal1[c(3,1)]) +
    guides(fill= FALSE,
           colour = FALSE)

# Add dummy upper/lower for CI that exceed 1 or 0
prop_fail_dat_som2$upr_dummy <-
    ifelse(prop_fail_dat_som2$upr <= 1,
           prop_fail_dat_som2$upr, 1)
prop_fail_dat_som2$upr_line <-
    ifelse(prop_fail_dat_som2$upr <= 1,
           "solid", "dotted")

prop_fail_dat_som2$lwr_dummy <-
    ifelse(prop_fail_dat_som2$lwr >= 0,
           prop_fail_dat_som2$lwr, 0)
prop_fail_dat_som2$lwr_line <-
    ifelse(prop_fail_dat_som2$lwr >= 0,
           "solid", "dotted")


pd6b <-
    ggplot(data = prop_fail_dat_som2, 
           aes(x = year,
               y = prop_fail * 100,
               colour = year)) +
    # Errorbar to get the horizontal part of the error bars
    geom_errorbar(aes(ymin = lwr * 100, 
                      ymax = upr * 100),
                  width = errorwidth,
                  size = linewidth,
                  position = position_dodge(width = 0.5)) +
    # Custom error bars
    geom_segment(aes(xend = year,
                     yend = lwr_dummy * 100,
                     linetype = lwr_line),
                 position = position_dodge(width = 0.5),
                 size = linewidth) +
    geom_segment(aes(xend = year,
                     yend = upr_dummy * 100,
                     linetype = upr_line),
                 position = position_dodge(width = 0.5),
                 size = linewidth) +
    # Raw data
    geom_jitter(data = region_cc_som2,
                aes(y = (fail_patch_area / sum_patch_area) * 100),
                alpha = 0.2,
                shape = 16,
                size= 1) +
    # Model-predicted values
    geom_point(position = position_dodge(width = 0.5),
               fill = "white", shape = 21, size = 2) +
    # Rank across realms
    geom_text(aes(label = rank),
              position = position_dodge(width = 0.5),
              size = 1.5,
              show.legend = FALSE) +
    facet_grid(df_name ~ realm, 
               switch = "x") +
    ylab("Area unsuccessful connectivity (%)") +
    theme_bw() +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_text(size = title_size),
          axis.text.y = element_text(size = text_size),
          strip.text = element_text(size = lab_size),
          legend.text = element_text(size = title_size),
          legend.position = "none", 
          legend.direction = "horizontal",
          legend.margin = margin(0,0,0,0),
          panel.spacing = unit(0, units = "cm"),
          panel.grid = element_blank()) +
    scale_y_continuous(breaks = seq(0,100,25),
                       limits = c(-10,110)) +
    scale_colour_manual(values = cbpal1[c(3,1)]) +
    scale_linetype_manual(values = c("dotted", "solid"), 
                          guide = FALSE) +
    guides(color=guide_legend(title = NULL))

pd6_leg <- get_legend(pd6b + theme(legend.position = "top"))

pd6 <-
    ggdraw() +
    draw_plot(pd6_leg, x = 0, y = 0.95, height = 0.05) +
    draw_plot(pd6a, x = 0, y = 0.48, height = 0.48) +
    draw_plot(pd6b, x = 0, y = 0, height = 0.48) +
    draw_plot_label(label = c("(a)", "(b)"),
                    x = rep(0.001, 2),
                    y = c(0.95,0.47),
                    size = lab_size)
pd6
```

From 2000 to 2012 we found that median climate connectivity did not change regardless of the minimum patch size applied (P > 0.05; \autoref{fig:fig-D-6}a), and this was true regardless of biogeographic realm (P > 0.05; \autoref{fig:fig-D-6}a). The change in proportion of unsuccessfully connected forest was, however, more complicated. For extremes of minimum patch size -- either 1 km^2^ of 100 km^2^ -- there was no effect of year (P > 0.05; \autoref{fig:fig-D-6}b). In the former case, it may be that any effect of year is masked by the greater amount of noise associated with an abundance of 1 km^2^ patches. In the latter case it is likely that so few 100 km^2^ patches were present at all that statistical power is lost, as well as the fact that patches of this size are likely to be more robust to relatively small changes in forest cover. For all other patch sizes, the proportion of successfully connected forest decreased from 2000 to 2012 (P < 0.01; \autoref{fig:fig-D-6}b). Only for a minimum patch size of 5 km^2^ was this relationship affected by realm (`r prop_fail_interaction_som2[2, "ref"]`), with a stronger loss of climate connectivity over time for the Afrotropics than in other realms. 

Loss of climate connectivity was strongly driven by loss of tree cover, regardless of minimum patch size (P < 0.001; \autoref{fig:fig-D-7}). The proportion of forest area losing connectivity differed by realm for all minimum patch sizes (P < 0.001; \autoref{fig:fig-D-7}), and was generally highest in Indomalaya, the Neotropics and the Afrotropics. In most cases climate connectivity was lost at an accelerating rate as the area of forest loss increased. It is likely that forest patches become smaller and increasingly isolated as more forest area is lost, to the point where vital connections are severed and climate connectivity is degraded. For  minimum patch size of 100 km^2^ there was a hump-shaped relationship with tree cover loss, which could be an artefact of there being fewer datapoints for this dataset at high values of tree cover loss.

(ref:cap-D-7) The proportion of total forested area in each land mass that lost climate connectivity between 2000 and 2012, with increasing area of forest loss and across different biogeographic realms (orange = Neotropics, blue = Afrotropics, green = Indomalaya, yellow = Australasia and pink = Oceania). Points correspond to raw data, with point size indicating the number of observations at that location. Fitted lines derive from model predictions with 95% confidence intervals.

```{r fig-D-7, fig.cap= "(ref:cap-D-7)", fig.width = 14/2.54}
pd7 <-
    ggplot(cc_loss_tc_loss_som2, 
           aes(x = tc_loss_log1p,
               y = prop_decrease_cc * 100,
               colour = realm)) +
    geom_ribbon(aes(ymin = lwr,
                    ymax = upr,
                    fill = realm,
                    colour = NULL),
                alpha = 0.3) +
    geom_count(data = region_ccc_som2,
               alpha = 0.5) +
    geom_line()+
    facet_wrap(~ df_name, nrow = 1) +
    xlab(paste("Area of forest loss (km","\U00B2",")",sep="")) +
    ylab("Area losing connectivity (%)") +
    theme_bw() +
    theme(axis.text.y = element_text(size = text_size),
          axis.text.x = element_text(size = text_size, 
                                     angle = 45,
                                     hjust = 1),
          axis.title = element_text(size = title_size),
          legend.direction = "horizontal", 
          legend.position = "top",
          legend.text = element_text(size = title_size),
          legend.box = "vertical",
          legend.spacing = unit(0, "cm"),
          legend.margin = margin(0,0,0,0,unit = "mm"),
          panel.grid = element_blank()) +
    scale_y_continuous(breaks = seq(0,100,10)) +
    scale_x_continuous(breaks = log1p(c(0, 10, 100, 1000, 10000, 100000)),
                       labels = c(0, 10, 100, "1,000", "10,000", "100,000")) +
    guides(colour = guide_legend(title = NULL,
                                 nrow=1,byrow=TRUE),
           fill = guide_legend(title = NULL,
                               nrow=2,byrow=TRUE),
           size = guide_legend(title = NULL, nrow = 1)) +
    scale_colour_manual(values = cbpal2) +
    scale_fill_manual(values = cbpal2)
pd7
```

\pagebreak

## Supplementary analyses without tree plantations {#text-D-2}

### Methods

The tree cover layers from @hansen_high-resolution_2013 do not currently distinguish between natural forests and tree plantations. However, boundary polygons for tree plantations are available for seven countries: Brazil, Cambodia, Colombia, Indonesia, Liberia, Malaysia, and Peru [@transparent_world_tree_2015]. We therefore re-ran our analyses (see [Chapter 5: 'Methods'](#ch5-methods)) for these seven countries only, with and without cells inside tree plantations. We buffered country polygons by 100 km to prevent artificial truncation of climate gradients [cf. @mcguire_achieving_2016]. Statistical models were analogous to those in [Chapter 5](#ch5), except that biogeographic realm was not included as an explanatory variable because of the smaller and more uneven sample sizes in this subset of the data.

### Results and Discussion

Median climate connectivity in 2012 was `r median_cc_dat_som1$median_cc[median_cc_dat_som1$df_name == "With plantations" & median_cc_dat_som1$year == "2012"]`&deg;C including cells in tree plantations, versus `r median_cc_dat_som1$median_cc[median_cc_dat_som1$df_name == "Without plantations" & median_cc_dat_som1$year == "2012"]`&deg;C excluding tree plantations. Median climate connectivity did not differ by year in either case (P > 0.05; \autoref{fig:fig-D-4}a). Thus, regardless of the year or inclusion of tree plantations, typical tropical forest fails to connect patches to future analogous climates.

The percentage of forest that failed to achieve successful climate connectivity in 2012 was consistent regardless of whether tree plantations were included (`r signif(prop_fail_dat_som1$prop_fail[prop_fail_dat_som1$df_name == "With plantations" & prop_fail_dat_som1$year == "2012"] * 100, 3)`% if including plantations versus `r signif(prop_fail_dat_som1$prop_fail[prop_fail_dat_som1$df_name == "Without plantations" & prop_fail_dat_som1$year == "2012"] * 100, 3)`% excluding plantations), although the trends over time did differ. If cells inside plantations were included, there was a slight decrease (`r signif(prop_fail_dat_som1$prop_fail[prop_fail_dat_som1$df_name == "With plantations" & prop_fail_dat_som1$year == "2012"] * 100, 3) - signif(prop_fail_dat_som1$prop_fail[prop_fail_dat_som1$df_name == "With plantations" & prop_fail_dat_som1$year == "2000"] * 100, 3)`%) from 2000 to 2012 in the percentage of forest that was unsuccessfully connected (`r prop_fail_results_som1$ref[prop_fail_results_som1$df_name == "With plantations"]`). The opposite was true when cells inside plantations were excluded (`r prop_fail_results_som1$ref[prop_fail_results_som1$df_name == "Without plantations"]`), with the proportion of unsuccessfully connected forest increasing by `r signif(prop_fail_dat_som1$prop_fail[prop_fail_dat_som1$df_name == "Without plantations" & prop_fail_dat_som1$year == "2012"] * 100, 3) - signif(prop_fail_dat_som1$prop_fail[prop_fail_dat_som1$df_name == "Without plantations" & prop_fail_dat_som1$year == "2000"] * 100, 3)`% from 2000 to 2012. The discrepancy between datasets in the effect of year is very likely driven by increasing tree cover inside tree plantations. 

(ref:cap-D-4) Climate connectivity in the year 2000 (green) and 2012 (purple), including or excluding cells that fall inside tree plantations. Panel (a) shows results for median climate connectivity, with the dashed line indicating zero climate connectivity, at and above which successful climate connectivity is achieved. Panel (b) shows results for the proportion of total forested area that fails to achieve successful climate connectivity. Solid points are model-predicted values with 95% confidence intervals. Raw data are plotted in the background as semi-transparent points.

```{r fig-D-4, fig.cap= "(ref:cap-D-4)"}

pd4a <-
    ggplot(data = median_cc_dat_som1, 
           aes(x = year,
               y = median_cc)) +
    geom_hline(yintercept = 0, 
               linetype = "dashed",
               size = 0.8) +
    geom_blank() +
    geom_rect(aes(xmin = -Inf,
                  xmax = Inf,
                  ymin = -Inf,
                  ymax = 0),
              fill = cbpal2[5],
              alpha = 0.2) +
    geom_rect(aes(xmin = -Inf,
                  xmax = Inf,
                  ymin = 0,
                  ymax = Inf),
              fill = cbpal2[7],
              alpha = 0.2) +
    geom_jitter(data = region_cc_som1,
                aes(x = year,
                    y = median_cc,
                    colour = year,
                    fill = year),
                alpha = 0.2,
                shape = 21,
                size= 0.5) +
    geom_errorbar(aes(ymin = lwr, 
                      ymax = upr), 
                  width = 0.2,
                  position = position_dodge(width = 0.5)) +
    geom_point(aes(fill = year),
               shape = 21,
               position = position_dodge(width = 0.5),
               size = 1.5) +
    facet_wrap(~ df_name, nrow = 1, strip.position="bottom") +
    ylab(paste("Median climate connectivity (", "\U00B0","C)",sep="")) +
    theme_bw() +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_text(size = title_size),
          axis.text.y = element_text(size = text_size),
          strip.text = element_text(size = lab_size),
          legend.text = element_text(size = lab_size),
          legend.position = c(0.1, 0.94),
          legend.key.size = unit(4, units = "mm"),
          legend.key = element_rect(fill="transparent"),
          legend.background = element_rect(fill="transparent"),
          legend.margin = margin(0,0,0,0),
          panel.spacing = unit(0, units = "cm"),
          panel.grid = element_blank()) +
    scale_y_continuous(breaks = seq(-4,4,0.5)) +
    scale_colour_manual(values = cbpal1[c(3,1)]) +
    scale_fill_manual(values = cbpal1[c(3,1)]) +
    guides(fill=guide_legend(title = NULL),
           colour=guide_legend(title = NULL))

pd4b <-
    ggplot(data = prop_fail_dat_som1, 
           aes(x = year,
               y = prop_fail * 100,
               colour = year)) +
    geom_point(position = position_dodge(width = 0.5)) +
    geom_errorbar(aes(ymin = lwr * 100, ymax = upr * 100), 
                  width = 0.2,
                  position = position_dodge(width = 0.5)) +
    geom_jitter(data = region_cc_som1,
                aes(y = (fail_patch_area / sum_patch_area) * 100),
                alpha = 0.2,
                shape = 16,
                size= 1) +
    facet_wrap(~ df_name, nrow = 1, strip.position="bottom") +
    ylab("Area unsuccessful connectivity (%)") +
    theme_bw() +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_text(size = title_size),
          axis.text.y = element_text(size = text_size),
          strip.text = element_text(size = lab_size),
          legend.title = element_blank(),
          legend.text = element_text(size = 4),
          legend.position = "none", 
          legend.direction = "horizontal",
          panel.spacing = unit(0, units = "cm"),
          panel.grid = element_blank()) +
    scale_y_continuous(breaks = seq(-0,100,10)) +
    scale_colour_manual(values = cbpal1[c(3,1)])

pd4 <-
    plot_grid(pd4a, pd4b, 
              nrow = 1, ncol = 2,
              align = "hv",
              labels = c("(a)", "(b)"), 
              label_size = lab_size)
pd4
```

From 2000 to 2012, loss of climate connectivity increased with increasing loss of forest area. This was true whether including tree plantations (`r cc_loss_results_som1$ref[cc_loss_results_som1$df_name == "With plantations"]`) or excluding tree plantations (`r cc_loss_results_som1$ref[cc_loss_results_som1$df_name == "Without plantations"]`). The relationship for both datasets was weaker than in the full model (see [Chapter 5](#ch5)), and when including plantations the relationship appeared to invert for very high loss of forest area. These results may be caused by the smaller sample size and truncation of climate gradients (e.g. from the Amazon to parts of the Andes) when focusing only on countries with tree plantation data. It is also possible that very high loss of forest area is concentrated in places which have already lost climate connectivity, and therefore have little left to lose. 

(ref:cap-D-5) The proportion of total forested area in each land mass that lost climate connectivity between 2000 and 2012 with increasing area of forest loss, including or excluding cells inside tree plantations. Points correspond to raw data. Fitted lines derive from model predictions with 95% confidence intervals.

```{r fig-D-5, fig.cap= "(ref:cap-D-5)"}
pd5 <-
    ggplot(cc_loss_tc_loss_som1, 
           aes(x = tc_loss_log1p,
               y = prop_decrease_cc * 100)) +
    geom_ribbon(aes(ymin = lwr * 100,
                    ymax = upr * 100),
                alpha = 0.3) +
    geom_point(data = region_ccc_som1,
               alpha = 0.7) +
    geom_line()+
    facet_wrap(~df_name) +
    xlab(paste("Area of forest loss (km","\U00B2",")",sep="")) +
    ylab("Proportion area losing connectivity (%)") +
    theme_bw() +
    theme(axis.text.y = element_text(size = text_size),
          axis.text.x = element_text(size = text_size, 
                                     angle = 45,
                                     hjust = 1),
          axis.title = element_text(size = title_size),
          legend.direction = "horizontal", 
          legend.position = "top",
          legend.text = element_text(size = text_size),
          legend.box = "vertical",
          legend.spacing = unit(0, "cm"),
          panel.grid = element_blank()) +
    scale_y_continuous(breaks = seq(0,100,10)) +
    scale_x_continuous(breaks = log1p(c(0, 10, 100, 1000, 10000, 100000)),
                       labels = c(0, 10, 100, "1,000", "10,000", "100,000")) +
    guides(colour = guide_legend(title = NULL),
           size = guide_legend(title = NULL, nrow = 1)) +
    scale_colour_manual(values = cbpal2[c(7,6)])
pd5
```

\pagebreak

## Supplementary analyses for different RCP scenarios {#text-D-3}

### Methods

In [Chapter 5](#ch5) we used Representative Concentration Pathway (RCP) 8.5 to derive Mean Annual Temperature in the year 2070. This is the most severe ('business-as-usual') IPCC scenario [@ipcc_climate_2013], which has thus far been the best predictor of observed climate change [@sanford_climate_2014]. However, it is possible that by 2070 stronger mitigating action is taken. We therefore repeated our analyses using RCP2.6, which is the least severe warming scenario. All methods were identical to those in [Chapter 5](#ch5), changing only the layer used for future temperature.

### Results and Discussion

For both RCP scenarios, median climate connectivity differed between realms (P < 0.001; \autoref{fig:fig-D-8}a), being highest in the Neotropics, Afrotropics and Indomalaya and lowest in Australasia and Oceania. Median climate connectivity was below zero for both scenarios, but closer to zero for RCP2.6 than RCP8.5. The implication is that forest patches across the tropics will generally fail to facilitate species range shifts to the extent that species could completely avoid climate warming, but with mitigation the amount of warming experienced would be less.

The proportion of forest area that failed to achieve successful climate connectivity (&ge; 0) in the year 2012 was influenced by biogeographic realm in both RCP scenarios (P < 0.001; \autoref{fig:fig-D-8}b). All realms were less  successfully connected using RCP8.5 (percentage area that was unsuccessful ranged from `r min(signif(filter(prop_fail_dat_som3, year == "2012", df_name == "RCP8.5") %>% .[,"prop_fail"] * 100, 2))`-`r max(signif(filter(prop_fail_dat_som3, year == "2012", df_name == "RCP8.5") %>% .[,"prop_fail"] * 100, 2))`% in RCP8.5 vs. `r min(signif(filter(prop_fail_dat_som3, year == "2012", df_name == "RCP2.6") %>% .[,"prop_fail"] * 100, 2))`-`r max(signif(filter(prop_fail_dat_som3, year == "2012", df_name == "RCP2.6") %>% .[,"prop_fail"] * 100, 2))`% in RCP2.6) and the ranking of different realms was also different depending on the RCP scenario. In both scenarios, Indomalaya and Oceania were among the least successfully connected and Australasia the best. The Afrotropics, however, had the lowest proportion of connected forest in 2012 under RCP2.6, but the second highest under RCP8.5. The Neotropics had the second highest proportion of connected forest in 2012 under RCP2.6, versus the second lowest for RCP8.5. Overall, these results suggest that despite the low average climate connectivity in both scenarios of future warming, strong mitigation like that assumed under RCP2.6 could maintain high climate connectivity in large forest patches.

(ref:cap-D-8) Climate connectivity in the year 2000 (green) and 2012 (purple), for RCP2.6 (least severe warming scenario) and RCP8.5 (most severe warming scenario). Panel (a) shows results for median climate connectivity, with the dashed line indicating zero climate connectivity, at and above which successful climate connectivity is achieved. Panel (b) shows results for the proportion of total forested area that fails to achieve successful climate connectivity. Hollow circles are model-predicted values with 95% confidence intervals. The small number in the centre indicates rank: 1 corresponds to the smallest y value for that realm and dataset, through to 5 for the highest value. Raw data are plotted in the background as semi-transparent, filled points. Confidence intervals in panel (b) are plotted with dotted lines where they extend beyond 0 or 100%. 

```{r fig-D-8, fig.cap= "(ref:cap-D-8)", fig.height= 21/2.54}
linewidth <- 0.3
errorwidth <- 0.2

pd8a <-
    ggplot(data = median_cc_dat_som3, 
           aes(x = year,
               y = median_cc)) +
    geom_hline(yintercept = 0, 
               linetype = "dashed",
               size = 0.5) +
    geom_blank() +
    geom_rect(aes(xmin = -Inf,
                  xmax = Inf,
                  ymin = -Inf,
                  ymax = 0,
                  colour = NULL),
              fill = cbpal2[5],
              alpha = 0.2) +
    geom_rect(aes(xmin = -Inf,
                  xmax = Inf,
                  ymin = 0,
                  ymax = Inf,
                  colour = NULL),
              fill = cbpal2[7],
              alpha = 0.1) +
    geom_jitter(data = region_cc_som3,
                aes(x = year,
                    y = median_cc,
                    colour = year,
                    fill = year),
                alpha = 0.3,
                shape = 21,
                size= 0.5) +
    geom_errorbar(aes(ymin = lwr, 
                      ymax = upr),
                  width = errorwidth,
                  size = linewidth,
                  position = position_dodge(width = 0.5)) +
    geom_point(aes(colour = year),
               fill = "white",
               position = position_dodge(width = 0.5),
               shape = 21,
               size = 2) +
    geom_text(aes(label = rank,
                  colour = year),
              position = position_dodge(width = 0.5),
              size = 1.5,
              show.legend = FALSE) +
    facet_grid(df_name ~ realm, 
               switch = "x",
               scales = "free") +
    ylab(paste("Median climate connectivity (", "\U00B0","C)",sep="")) +
    theme_bw() +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_text(size = title_size),
          axis.text.y = element_text(size = text_size),
          strip.text = element_text(size = lab_size),
          panel.spacing = unit(0, units = "cm"),
          panel.grid = element_blank()) +
    scale_colour_manual(values = cbpal1[c(3,1)]) +
    scale_fill_manual(values = cbpal1[c(3,1)]) +
    guides(fill= FALSE,
           colour = FALSE)

# Add dummy upper/lower for CI that exceed 1 or 0
prop_fail_dat_som3$upr_dummy <-
    ifelse(prop_fail_dat_som3$upr <= 1,
           prop_fail_dat_som3$upr, 1)
prop_fail_dat_som3$upr_line <-
    ifelse(prop_fail_dat_som3$upr <= 1,
           "solid", "dotted")

prop_fail_dat_som3$lwr_dummy <-
    ifelse(prop_fail_dat_som3$lwr >= 0,
           prop_fail_dat_som3$lwr, 0)
prop_fail_dat_som3$lwr_line <-
    ifelse(prop_fail_dat_som3$lwr >= 0,
           "solid", "dotted")


pd8b <-
    ggplot(data = prop_fail_dat_som3, 
           aes(x = year,
               y = prop_fail * 100,
               colour = year)) +
    # Errorbar to get the horizontal part of the error bars
    geom_errorbar(aes(ymin = lwr * 100, 
                      ymax = upr * 100),
                  width = errorwidth,
                  size = linewidth,
                  position = position_dodge(width = 0.5)) +
    # Custom error bars
    geom_segment(aes(xend = year,
                     yend = lwr_dummy * 100,
                     linetype = lwr_line),
                 position = position_dodge(width = 0.5),
                 size = linewidth) +
    geom_segment(aes(xend = year,
                     yend = upr_dummy * 100,
                     linetype = upr_line),
                 position = position_dodge(width = 0.5),
                 size = linewidth) +
    # Raw data
    geom_jitter(data = region_cc_som3,
                aes(y = (fail_patch_area / sum_patch_area) * 100),
                alpha = 0.2,
                shape = 16,
                size= 1) +
    # Model-predicted values
    geom_point(position = position_dodge(width = 0.5),
               fill = "white", shape = 21, size = 2) +
    # Rank across realms
    geom_text(aes(label = rank),
              position = position_dodge(width = 0.5),
              size = 1.5,
              show.legend = FALSE) +
    facet_grid(df_name ~ realm, 
               switch = "x") +
    ylab("Area unsuccessful connectivity (%)") +
    theme_bw() +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_text(size = title_size),
          axis.text.y = element_text(size = text_size),
          strip.text = element_text(size = lab_size),
          legend.text = element_text(size = title_size),
          legend.position = "none", 
          legend.direction = "horizontal",
          legend.margin = margin(0,0,0,0),
          panel.spacing = unit(0, units = "cm"),
          panel.grid = element_blank()) +
    scale_y_continuous(breaks = seq(0,100,25),
                       limits = c(-10,110)) +
    scale_colour_manual(values = cbpal1[c(3,1)]) +
    scale_linetype_manual(values = c("dotted", "solid"), 
                          guide = FALSE) +
    guides(color=guide_legend(title = NULL))

pd8_leg <- get_legend(pd8b + theme(legend.position = "top"))

pd8 <-
    ggdraw() +
    draw_plot(pd8_leg, x = 0, y = 0.95, height = 0.05) +
    draw_plot(pd8a, x = 0, y = 0.48, height = 0.48) +
    draw_plot(pd8b, x = 0, y = 0, height = 0.48) +
    draw_plot_label(label = c("(a)", "(b)"),
                    x = rep(0.001, 2),
                    y = c(0.95,0.47),
                    size = lab_size)
pd8
```

For both RCP scenarios we found that median climate connectivity did not change between 2000 and 2012 (P > 0.05), and this was consistent across biogeographic realms (P > 0.05; \autoref{fig:fig-D-8}b). In contrast, the proportion of forest area that failed to achieve successful climate connectivity was generally higher in 2012 than 2000, for both RCP2.6 (`r filter(prop_fail_results_som3, EV == "year", df_name == "RCP2.6") %>% dplyr::select(ref)`) and RCP8.5 (`r filter(prop_fail_results_som3, EV == "year", df_name == "RCP8.5") %>% dplyr::select(ref)`). Under both scenarios this pattern depended on the biogeographic realm (P < 0.001), with the biggest losses in the Neotropics and Indomalaya compared to a decrease in the Afrotropics (\autoref{fig:fig-D-8}b).

The proportion of forest experiencing a decrease in climate connectivity from 2000 to 2012 was influenced by both the area of forest loss (P < 0.001) and biogeographic realm (P < 0.001; \autoref{fig:fig-D-9}), in both RCP scenarios. Indomalaya and the Neotropics experienced substantial loss of climate connectivity in both scenarios, while the magnitude of change varied between scenarios for the Afrotropics, Oceania and Australasia (\autoref{fig:fig-D-9}). In both scenarios the relationship between connectivity loss and forest loss is non-linear, however under RCP2.6 the steepness of this relationship decreases for very high values of forest loss, while it increases under RCP8.5. This discrepancy should be interpreted with caution since there are only a small number of datapoints at the upper end of the relationship, but the implication is that there is a greater propensity for climate connectivity loss to accelerate under a business-as-usual compared to a strong mitigation scenario.

(ref:cap-D-9) The proportion of total forested area in each land mass that lost climate connectivity between 2000 and 2012, with increasing area of forest loss and across different biogeographic realms (orange = Neotropics, blue = Afrotropics, green = Indomalaya, yellow = Australasia and pink = Oceania). Points correspond to raw data, with point size indicating the number of observations at that location. Fitted lines derive from model predictions with 95% confidence intervals.

```{r fig-D-9, fig.cap= "(ref:cap-D-9)", fig.width = 12/2.54}
pd9 <-
    ggplot(cc_loss_tc_loss_som3, 
           aes(x = tc_loss_log1p,
               y = prop_decrease_cc * 100,
               colour = realm)) +
    geom_ribbon(aes(ymin = lwr * 100,
                    ymax = upr * 100,
                    fill = realm,
                    colour = NULL),
                alpha = 0.3) +
    geom_count(data = region_ccc_som3,
               alpha = 0.5) +
    geom_line()+
    facet_wrap(~ df_name, nrow = 1) +
    xlab(paste("Area of forest loss (km","\U00B2",")",sep="")) +
    ylab("Area losing connectivity (%)") +
    theme_bw() +
    theme(axis.text.y = element_text(size = text_size),
          axis.text.x = element_text(size = text_size, 
                                     angle = 45,
                                     hjust = 1),
          axis.title = element_text(size = title_size),
          legend.direction = "horizontal", 
          legend.position = "top",
          legend.text = element_text(size = text_size),
          legend.box = "vertical",
          legend.spacing = unit(0, "cm"),
          legend.margin = margin(0,0,0,0,unit = "mm"),
          panel.grid = element_blank()) +
    scale_y_continuous(breaks = seq(0,100,10)) +
    scale_x_continuous(breaks = log1p(c(0, 10, 100, 1000, 10000, 100000)),
                       labels = c(0, 10, 100, "1,000", "10,000", "100,000")) +
    guides(colour = guide_legend(title = NULL,
                                 nrow=1,byrow=TRUE),
           fill = guide_legend(title = NULL,
                               nrow=2,byrow=TRUE),
           size = guide_legend(title = NULL, nrow = 1)) +
    scale_colour_manual(values = cbpal2) +
    scale_fill_manual(values = cbpal2)
pd9
```

\pagebreak

## Worked example of climate connectivity calculation {#text-D-4}

The following text provides a step-by-step calculation of climate connectivity in the Brazilian states of Rond&ocirc;nia and Mato Grosso.

### Step 1: Creating forest patches {#step-1}

Climate connectivity is calculated using climate-partitioned patches of natural habitat [@mcguire_achieving_2016]. In this study natural habitat refers to tropical forest, derived from @hansen_high-resolution_2013 for the years 2000 and 2012. For the year 2000, cells were classed as forested if they had > 50% tree cover [\autoref{fig:fig-D-1}a; @hansen_high-resolution_2013]. For the year 2012, cells were classed as forest based on forest loss and forest gain, relative to forest cover in 2000 (\autoref{fig:fig-D-1}b). If a cell experienced forest loss, it had gone from a forested to non-forested state between 2000 and 2012 and was classed as non-forest. If a cell had experienced forest gain, it had gone from a non-forested to forested state between 2000 and 2012; providing there had been no concomitant loss, the cell was classed as forest. All subsequent steps were applied separately to forest cover in 2000 and 2012.

(ref:cap-D-1) Tree cover in the year 2000 (a) ranges from low (white) to high (dark green). Tree cover change from 2000 to 2012 (b) includes: no change (blue), forest loss (purple), forest gain (green) or both loss and gain (yellow). Both layers derive from @hansen_high-resolution_2013, and are used to classify cells into either forest or non-forest in the years 2000 and 2012.

```{r, echo = FALSE, include = FALSE}
p1a <-
    ggplot()+
    geom_raster(data = tc2000_raw, 
                aes(x = x, y = y, fill = forest_cover)) +
    geom_polygon(data = sub_boundary, 
                 aes(x = long, y = lat,
                     group = group),
                 colour = "grey40",
                 size = 0.1,
                 alpha = 0) +
    theme_void() +
    theme(legend.title = element_text(size = title_size),
          legend.text = element_text(size = text_size),
          legend.box.spacing = unit(0,"cm"),
          legend.box.margin = margin(0,0,0,0),
          legend.position = "right") +
    coord_equal(ratio=1) +
    scale_fill_gradient(low = "beige", 
                        high = "darkgreen", 
                        name = "Tree cover\nin 2000 (%)") 
p1b <-
    ggplot()+
    geom_raster(data = gainloss, 
                aes(x = x, y = y, fill = gain_loss)) +
    theme_void() +
    theme(legend.text = element_text(size = title_size),
          legend.box.spacing = unit(0,"cm"),
          legend.box.margin = margin(0,0,0,0),
          legend.position = "right") +
    coord_equal(ratio=1) +
    scale_fill_manual(values = cbpal1[c(2,1,3,4)]) +
    guides(fill=guide_legend(title = NULL),
           colour=guide_legend(title = NULL))
```

```{r fig-D-1, fig.cap= "(ref:cap-D-1)", echo = FALSE}
plot_grid(p1a, p1b, 
          align = "hv",
          nrow = 2, 
          labels = c("(a)", "(b)"), 
          label_size = lab_size,
          label_x = 0.2)
```

We used Mean Annual Temperature (MAT) as our climate variable, which is the first bioclimatic variable of the WorldClim database [Version 1.4; @hijmans_very_2005]. All layers (forest cover and climate data) were projected into the World Cylindrical Equal Area projection and re-sampled to 1 km^2^ resolution. Current climate (~1950-2000) was assigned to forested cells, and rounded to increments of 0.5&deg;C. Adjacent cells with the same temperature were assigned to the same patch (\autoref{fig:fig-D-2}). Patches less than 10 km^2^ in area were removed, and patches within 2 km of each other were assigned to the same patch. Once forest patches had been determined we re-calculated current temperature (so it was no longer rounded to increments of 0.5&deg;C), and calculated future temperature for each patch in the year 2070 (2061-2080) using data from the HadGEM2-AO general circulation model [@ipcc_climate_2013] and Representative Concentration Pathway (RCP) 8.5, which is the most severe ('business-as-usual') IPCC scenario.

(ref:cap-D-2) Forest patches in 2000 (a) and 2012 (b). Black inset (c) corresponds to magnified view of the subset of patches used below to calculate climate connectivity. Shading indicates unique patches and numbers correspond to patch identities, a sample of which can be found in \autoref{tab:tab-D-1}.

```{r, echo = FALSE, include = FALSE}
# Define custom function to ensure colour scheme is standardised
plot_patches <- 
    function(.data, colours = patch_pal){
        ggplot() + 
            geom_polygon(data = .data, 
                         aes(x=long, y=lat, 
                             fill= patch, 
                             group = group)) +
            scale_fill_manual(values = colours,
                              guide = FALSE)
    }

p2a <- 
    plot_patches(patches_poly) +
    geom_polygon(data = sub_boundary, 
                 aes(x = long, y = lat,
                     group = group),
                 colour = "grey40",
                 alpha = 0,
                 size = 0.1) +
    geom_rect(data = sub_extent,
              aes(xmin = xmin,
                  xmax = xmax,
                  ymin = ymin,
                  ymax = ymax,
                  linetype = factor(year)),
              colour = "black",
              size = 0.5,
              alpha = 0) +
    facet_wrap(~ year) +
    theme_void() +
    theme(legend.text = element_text(size = text_size),
          legend.title = element_text(size = text_size)) +
    coord_equal(ratio=1) +
    scale_linetype_manual(values = c("solid","blank"),
                          guide = FALSE)

centroids <- patches_sub[!duplicated(patches_sub$patch),]
# patches_sub$jit <-
#     with(patches_sub, 
#          ifelse(patch == "KS" | abbrev == "LA", 1, 2))

p2b <- 
    plot_patches(patches_sub) +
    geom_rect(data = sub_extent,
              aes(xmin = xmin - 10000,
                  xmax = xmax + 5000,
                  ymin = ymin - 5000,
                  ymax = ymax + 5000,
                  linetype = factor(year)),
              colour = "black",
              linetype = "solid",
              size = 0.1,
              alpha = 0) +
    geom_text_repel(data = centroids, 
              aes(x = long, y = lat, 
                  label = patch,
                  group = group),
              size = 1.8,
              force=1.5,
              segment.size=0.1,
              min.segment.length = unit(0, "lines"),
              point.padding = unit(0, "lines"))+
    theme_void() +
    theme(legend.text = element_text(size = text_size),
          legend.title = element_text(size = text_size)) +
    coord_equal(ratio=1) +
    scale_linetype(guide = FALSE)
```

```{r fig-D-2, fig.cap = "(ref:cap-D-2)", echo = FALSE, fig.height= 15/2.54}
ggdraw() +
    draw_plot(p2a, x = 0, y = 0.5, height = 0.5) +
    draw_plot(p2b, x = 0, y = 0, height = 0.5) +
    draw_plot_label(label = c("(a)", "(b)", "(c)"),
                    x = c(0.1, 0.5, 
                          0.3),
                    y = c(rep(0.98, 2), 0.48),
                    size = lab_size)
```


### Step 2: Identifying destination patches {#step-2}

Climate connectivity for a given patch depends on the difference between the current temperature of that patch, and the future temperature of the coolest patch that can be reached by traversing a gradient of hotter to cooler adjacent patches [@mcguire_achieving_2016]. The aim of this next step, therefore, was to determine the coolest destination patch for each origin patch.

We first identified, for each pair of neighbouring patches, which of the two was the hotter 'origin' patch and which was the cooler 'destination' patch. In the code snippets below, `nbr` refers to a dataframe of patch neighbours, and `temp_dat` is a dataframe of the current and future temperature for all patches.

```{r, echo = FALSE}
nbr <- arrange(nbr, patch1, patch2)
t1a <- head(nbr)
```

```{r, echo = TRUE}
nbr$origin <- NA
nbr$dest <- NA
nbr$origin_temp <- NA
nbr$dest_temp <- NA

for (i in 1:nrow(nbr)){
    # If temp1 is more than temp2, patch1 is the origin and 
    # patch 2 is the destination
    if(nbr$temp1[i] > nbr$temp2[i]){
        nbr$origin[i] <- nbr$patch1[i]
        nbr$origin_temp[i] <- nbr$temp1[i]
        nbr$dest[i] <-nbr$patch2[i]
        nbr$dest_temp[i] <- nbr$temp2[i]
        # If temp2 is more than temp1, patch2 is the origin and 
        # patch 1 is the destination
    }else{
        nbr$origin[i]<- nbr$patch2[i]
        nbr$origin_temp[i] <- nbr$temp2[i]
        nbr$dest[i]<-nbr$patch1[i]
        nbr$dest_temp[i] <- nbr$temp1[i]
    }
}
```

```{r, echo = FALSE}
# Merge cdat and fdat
temp_dat <- merge(cdat, fdat, by = "patch")
rm(cdat, fdat)
# Remove unnecessary variables
nbr <- nbr[,c("origin", "dest", "origin_temp", "dest_temp")]
nbr <- arrange(nbr, dest, origin)
```

```{r tab-D-1, echo=FALSE, results='asis'}
# t1a <- kable(t1a, format = "latex", booktabs = TRUE)
# t1b <- kable(head(nbr), format = "latex", booktabs = TRUE)
# 
# cat(c("\\begin{table}[!htb]
#     \\caption{(\\#tab:tab-D-1) Dataframe of patch neighbours before (a) and after (b) sorting neighbours into either the hotter origin patch or cooler destination patch.}
#     \\begin{subtable}{.5\\linewidth}
#       \\centering",
#     t1a,
#     "\\caption{}\\end{subtable}%
#     \\begin{subtable}{.5\\linewidth}
#       \\centering",
#     t1b,
#     "\\caption{} \\end{subtable} 
# \\end{table}"
# ))
```

\begin{table}[!htb]
\begin{subtable}{.5\linewidth}
\caption{} 
\centering 
\begin{tabular}{rrrr}
\toprule
patch1 & patch2 & temp1 & temp2\\
\midrule
12 & 53 & 22.0 & 22.5\\
43 & 108 & 22.7 & 22.9\\
43 & 224 & 22.7 & 23.5\\
43 & 387 & 22.7 & 24.0\\
45 & 111 & 22.6 & 22.9\\
45 & 224 & 22.6 & 23.5\\
\bottomrule
\end{tabular}
\end{subtable}
\begin{subtable}{.5\linewidth}
\caption{} 
\centering 
\begin{tabular}{rrrr}
\toprule
origin & dest & origin\_temp & dest\_temp\\
\midrule
53 & 12 & 22.5 & 22.0\\
108 & 43 & 22.9 & 22.7\\
224 & 43 & 23.5 & 22.7\\
387 & 43 & 24.0 & 22.7\\
111 & 45 & 22.9 & 22.6\\
224 & 45 & 23.5 & 22.6\\
\bottomrule
\end{tabular} 
\end{subtable} 
\caption{(\#tab:tab-D-1) Dataframe of patch neighbours before (a) and after (b) sorting neighbours into either the hotter origin patch or cooler destination patch.}
\end{table}

Most patches have multiple neighbours, so we next identified *all* the neighbours for each origin patch (assigned to: `connections`). For example, we can see below that origin patch 135 has only one neighbour: patch 53. Patch 231 has no neighbours, and patch 224 has many.

```{r connections, echo = TRUE}
connections <-
    sapply(1:nrow(temp_dat), function(x){
        nbr$dest[nbr$origin == temp_dat[x,"patch"]]
    })
names(connections) <- temp_dat$patch
# Look at a subset of patch connections:
connections[20:22]
```

To determine the final, coolest destination patch that can be reached from each origin patch, we traced the path according to which of the immediate neighbours was the coolest. This step was done by iterating over unique patch temperatures (`uniquetemps`), from cooler to hotter.

```{r uniquetemps, echo = TRUE}
uniquetemps <- sort(unique(temp_dat$temp))
uniquetemps
```

We created variables in `temp_dat` to populate with the temperature and patch identity of the final destination patch for each origin patch, and created a copy of this dataframe called `running`. The dataframe `running` is updated with each iteration.

```{r output, echo = TRUE}
# Set up output columns
temp_dat$dest <- NA
temp_dat$dest_temp <- NA
temp_dat$inter_patch <- NA

# Copy the original dataframe
running <- temp_dat[, c("patch", "temp")]
```

In each iteration through unique temperatures (from cooler to warmer) we identified:

* The origin patches that corresponded to that temperature;
* The coolest neighbour of each origin patch;

And subsequently we:

* Populated the empty columns in our original dataframe with the patch identity and temperature of the final destination patch of the coolest neighbour;
* Updated the `running` dataframe, to track the pathway from each origin patch to its final destination patch (which may or may not be an immediate neighbour).

The iterations below were run in a loop, but for illustrative purposes we will iterate over each unique temperature manually.

### Iteration 1 {#iter-1}

We begin by defining the focal unique temperature of this iteration. In this case, it's the first (i.e. coolest) value from our previously defined vector of unique temperatures, `uniquetemps`.

```{r iter-1, echo = TRUE}
this_temp <- uniquetemps[1]
this_temp
```

Next we define the indices of all patches that are 22&deg;C (`inds`).

```{r, echo = TRUE}
inds <- which(running[,"temp"] == this_temp)
running[inds, "patch"]
```

Patch number 12 is the only patch at this temperature. Now we need to see if patch 12 has any associated destination patches:

```{r, echo = TRUE}
length(connections[[inds]]) > 0
```

No, therefore the final destination patch and the final destination temperature are the same as the origin: patch 12, temperature 22&deg;C. The reason that we use the `running` dataframe (a copy of the original `temp_dat` dataframe) to retrieve the temperature and identity of the destination patch will become clear in later iterations (i.e. [Iteration 5](#iter-5)).

```{r, echo = TRUE}
temp_dat$dest[inds]<- running[inds, "patch"]
temp_dat$dest_temp[inds]<- this_temp
```

Let's look at the row in our dataframe that we have just populated:

```{r, echo = TRUE}
temp_dat[inds,]
```

Note that because the origin and destination patch are the same, there are no intermediate patches and so the value for `inter_patch` remains NA.

### Iteration 2 {#iter-2}

Moving onto the next unique temperature. This iteration is more complicated because the origin patch *does* have one or more neighbouring destination patches.

```{r iter-2a, echo = TRUE}
this_temp <- uniquetemps[2]
this_temp
```

Again we define the indices of all patches that have this temperature (22.5&deg;C).

```{r, echo = TRUE}
inds <- which(running[,"temp"] == this_temp)
running[inds, "patch"]
```

This time both patch 53 and patch 58 have the temperature that we're interested in. We start with patch 53 (index 1 in the vector `inds`). 

Are there any associated destination patches?

```{r, echo = TRUE}
length(connections[[inds[1]]]) > 0
```

Yes. We define the indices of the destination patches as well (`dest_inds`).

```{r, echo = TRUE}
dest_inds <- which(temp_dat$patch %in%  connections[[inds[1]]])
```

There may be multiple destination patches, so we need to identify the minimum temperature across all of them (`t`), as well as the index of the patch (or patches) that correspond to this minimum temperature (`min_ind`).

```{r, echo = TRUE}
t <- min(running[dest_inds, "temp"])
t
min_ind <- which(running[dest_inds, "temp"] == t)
```

Is there more than one destination patch that has this minimum temperature (22&deg;C)?

```{r, echo = TRUE}
length(min_ind) > 1
```

No, so `min_ind` is the index of the destination patch that we're interested in. If there were more than one destination patch with the same minimum temperature, the first would be used arbitrarily.

Which patch does this index correspond to?
```{r, echo = TRUE}
temp_dat$patch[min_ind]
```

Patch 12. This is the final destination patch for patch 53. We assign the final temperature (22&deg;C) and the identity of the final destination patch (12) to the associated origin patch (53) in our original dataframe, `temp_dat`. 

```{r, echo = TRUE}
temp_dat$dest_temp[inds[1]] <- t
temp_dat$dest[inds[1]] <- running$patch[min_ind]
```

We must also update the `running` dataframe so that patch 53 acquires the temperature and identity of patch 12. This step is vital for constructing more complicated pathways. In this example, since the final destination of patch 53 is patch 12, any origin patches in subsequent iterations whose neighbouring destination is patch 53 (see [Iteration 5](#iter-5)) will be assigned the final destination temperature and identity of patch 12, *not* patch 53.

```{r, echo = TRUE}
running$temp[inds[1]] <- t
running$patch[inds[1]] <- running$patch[min_ind]
```

Finally, we capture intermediate patches that are traversed from origin to destination. The path from patch 53 to patch 12 cannot have intermediate patches because patch 12 is its own destination (there were no neighbouring patches that were cooler; see [Iteration 1](#iter-1)).

```{r, echo = TRUE}
inter_patch <- temp_dat[min_ind, "inter_patch"]
is.na(inter_patch)
```

We assign the final destination patch as the only intermediate patch. This is not strictly necessary since we have already recorded patch 12 as part of the path because it is the destination. However, this step highlights the fact that in this iteration the destination patch is not the same as the origin patch.

```{r, echo = TRUE}
temp_dat$inter_patch[inds[1]] <- temp_dat[min_ind, "patch"]
```

We can now check the row for patch 53 in `temp_dat` and in the `running` dataframe. Note how in the `running` dataframe the row associated with patch 53 now has the identity and temperature of patch 12 instead.

```{r, echo = TRUE}
temp_dat[inds[1],]
running[inds[1],]
```

Remembering that there were two origin patches corresponding to the focal temperature of this iteration (22.5&deg;C), we must now repeat the above process for patch 58 (index 2 in the vector `inds`).

Does patch 58 have any neighbouring destination patches?

```{r iter-2b, echo = TRUE}
length(connections[[inds[2]]]) > 0
```

No. As with [Iteration 1](#iter-1), we assign the final destination temperature and patch identity to be the same as the origin. 

```{r, echo = TRUE}
temp_dat$dest[inds[2]]<- running[inds[2], "patch"]
temp_dat$dest_temp[inds[2]]<- this_temp
temp_dat[inds[2],]
```

```{r iter-3, echo = FALSE}
this_temp <- uniquetemps[3]

# Define indices of all patches that have this temperature
inds <- which(running[,"temp"] == this_temp)

for (k in 1:(length(inds))){
    ii <- inds[k]
    if(length(connections[[ii]]) == 0){
        temp_dat$dest_temp[ii]<- this_temp
        temp_dat$dest[ii]<- running[ii, "patch"]
    }
}
```

```{r iter-4, echo = FALSE}
this_temp <- uniquetemps[4]

# Define indices of all patches that have this temperature
inds <- which(running[,"temp"] == this_temp)

for (k in 1:(length(inds))){
    ii <- inds[k]
    if(length(connections[[ii]]) == 0){
        temp_dat$dest_temp[ii]<- this_temp
        temp_dat$dest[ii]<- running[ii, "patch"]
    }
}
```

### Iteration 5 {#iter-5}

We will now skip ahead to the fifth unique temperature, which illustrates the importance of updating the `running` dataframe in each iteration and using this to assign the temperature and identity of the final destination patch.

```{r iter-5, echo = TRUE}
this_temp <- uniquetemps[5]
this_temp

inds <- which(running[,"temp"] == this_temp)
running[inds, "patch"]
```

Patch 135 is the only origin patch that is 22.8&deg;C. Does it have any neighbouring destination patches?

```{r, echo = TRUE}
length(connections[[inds[1]]]) > 0
dest_inds <- which(temp_dat$patch %in%  connections[[inds[1]]])
```

Yes. Of the one or more neighbouring destination patches, what is the minimum temperature and what is the index of the corresponding patch?

```{r, echo = TRUE}
t <- min(running[dest_inds, "temp"])
t
min_ind <- dest_inds[which(running[dest_inds, "temp"] == t)]
```

Is there more than one destination patch at this minimum temperature (22&deg;C)?

```{r, echo = TRUE}
length(min_ind) > 1
temp_dat$patch[min_ind]
```

No. Patch 53 is the destination for patch 135. At this point, note that patch 53 was encountered in [Iteration 2](#iter-2), and is itself connected to patch 12. As such, the row corresponding to the index of patch 53 actually has the temperature and identity of patch 12:

```{r, echo = TRUE}
running[min_ind,]
```

Because the final destination temperature and patch identity are retrieved from the `running` dataframe, we assign the final destination identity and temperature as patch 12, 22&deg;C.

```{r, echo = TRUE}
temp_dat$dest_temp[inds[1]] <- t
temp_dat$dest[inds[1]] <- running$patch[min_ind]
```

We again update the `running` dataframe. In subsequent iterations any origin patch whose coolest neighbour is patch 135 will also be assigned the final destination temperature and identity of patch 12.

```{r, echo = TRUE}
running$temp[inds[1]] <- t
running$patch[inds[1]] <- running$patch[min_ind]
```

Lastly, we define the intermediate patches. 

```{r, echo = TRUE}
inter_patch <- temp_dat[min_ind, "inter_patch"]
is.na(inter_patch)
```

In this case of course there *is* an intermediate patch between the origin and the destination -- patch 53. We paste this patch together with the final destination to construct the full pathway from origin to destination.

```{r, echo = TRUE}
temp_dat$inter_patch[inds[1]] <-
    paste(temp_dat[min_ind, "patch"],
          inter_patch[!(is.na(inter_patch))],
          sep = ";")
```

Let's inspect the rows that we have just populated:

```{r, echo = TRUE}
temp_dat[inds[1],]
running[inds[1],]
```

```{r join-patches, echo = FALSE}
# Run it all together
#set up output file
temp_dat$dest <- NA
temp_dat$dest_temp <- NA
temp_dat$inter_patch <- NA

# Define temporary list of patchs and temps to update as patchs are
# connected to each other
running <- temp_dat[,c("patch", "temp")]

# Loop through each unique temperature, from colder to warmer
for (j in 1:length(uniquetemps)){
    # Define the focal unique temperature
    this_temp <- uniquetemps[j]
    # Define the indices of patchs that correspond to the focal temperature
    inds <- which(running[,"temp"] == this_temp)
    
    # Iterate over the indices
    for (k in 1:(length(inds))){
        ii <- inds[k]
        # If the focal patch associated with this index does not connect to
        # any other patch, the final destination patch is the same as the focal
        # patch and its final temp is the same as its starting temp
        if(length(connections[[ii]]) == 0){
            temp_dat$dest_temp[ii]<- this_temp
            temp_dat$dest[ii]<- running[ii, "patch"]
            # If it does connect to another patch...
        }else{
            # Retrieve indices of the destination patchs
            topatchsinds <- which(temp_dat$patch %in%  connections[[ii]])
            # Calculate which of the destination patchs has the lowest temperature
            t <- min(running[topatchsinds, "temp"])
            # Retrieve indices of the destination patchs that correspond to
            # this minimum temperature
            a <- which(running[topatchsinds, "temp"] == t)
            
            if(length(a)==1){
                # If there is only one coldest patch, index that destination (colder) patch &
                minind <- topatchsinds[a]
            }else{
                # If there is more than one colder patch w/ = temperatures, arbitrarily dplyr::select the first one
                minind <- topatchsinds[a[1]]
            }
            
            # Assign the min destination temp as the final temp. of the focal patch
            temp_dat$dest_temp[ii] <- t
            # Assign the final patch of the focal patch as its coldest (destination) patch
            temp_dat$dest[ii] <- running[minind, "patch"]
            # Assign the final patch and its intermediate patches
            inter_patch <- temp_dat[minind, "inter_patch"]
            
            if(!(is.na(inter_patch))){
                temp_dat$inter_patch[ii] <-
                    paste(temp_dat[minind, "patch"],
                          inter_patch[!(is.na(inter_patch))],
                          sep = ";")
            }else{
                temp_dat$inter_patch[ii] <- temp_dat[minind, "patch"]
            }
            # Assign the final temp of the focal patch as the new minimum temperature
            running[ii, "temp"] <- t
            # Have new colder (destination) patch replace the origin patch in runningpatch
            running[ii, "patch"] <- running[minind, "patch"]
        }
    }
}
```

### Step 3: Calculating climate connectivity {#step-3}

At this point we know the current and future temperature of all patches ([Step 1](#step-1)), and the identity and current temperature of their final destination patches ([Step 2](#step-2)). Combining this information we can easily assign to each origin patch the future temperature of its destination patch:

```{r dest-ftemp, echo = TRUE}
temp_dat$dest_ftemp <-
    vapply(1:nrow(temp_dat), function(x){
        dest <- temp_dat$dest[x]
        dest_ftemp <- temp_dat$ftemp[temp_dat$patch == dest]
        return(dest_ftemp)
    }, FUN.VALUE = numeric(1))
```

Finally, we calculate climate connectivity. Conceptually, climate connectivity is the maximum temperature difference that can be achieved by traversing a gradient of hotter to cooler adjacent patches. Mathematically, this is calculated as the current temperature of the origin patch minus the future temperature of the destination patch. If this value is zero or positive then climate connectivity is successful -- organisms could potentially reach a forest patch that, under climate change, is the same as or cooler than where they currently are.

```{r climate-connectivity, echo = TRUE}
temp_dat$clim_conn <- temp_dat$temp - temp_dat$dest_ftemp
```

Final results can be seen in \autoref{fig:fig-D-3} and \autoref{tab:tab-D-2}. \autoref{tab:tab-D-3} demonstrates what the `running` dataframe looks like after having updated for each iteration. 

```{r, echo = FALSE, include = FALSE}
centroids <- patches_sub[!duplicated(patches_sub$patch),]

# Merge results of connectivity analysis with centroids dataframe
centroids <- merge(centroids, temp_dat, by = "patch")

# Separate out intermediate patches and create long dataframe
int_patches <- centroids[!(duplicated(centroids$patch)),
                         c("patch", "inter_patch")]

int_patches <-
    int_patches %>% 
    mutate(inter_patch = strsplit(as.character(inter_patch), ";")) %>%
    tidyr::unnest(inter_patch) %>% 
    na.omit() %>%
    group_by(patch) %>% 
    mutate(seq = row_number())

# For each origin patch, assign the starting point as the 
# end point of the previous step

get_seq <- function(start_patch){
    
    sub_dat <- int_patches[int_patches$patch == start_patch,
                           c("patch", "inter_patch")]
    sub_dat$patch <- paste(sub_dat$patch) %>% as.integer()
    sub_dat$inter_patch <- paste(sub_dat$inter_patch) %>% as.integer()
    seq_len <- nrow(sub_dat)
    
    for(i in 1:seq_len){
        if(i > 1){
            sub_dat[i, "patch"] <- sub_dat[i - 1, "inter_patch"]
        }
    }
    colnames(sub_dat) <- c("start", "end")
    
    # Add the absolute starting patch
    sub_dat$abs_start <- sub_dat$start[1]
    
    return(as.data.frame(sub_dat))
}

int_patches <- lapply(unique(int_patches$patch), get_seq) %>%
    bind_rows()

# Add coordinates
int_patches <- merge(int_patches, 
                     centroids[,c("patch", "long", "lat")], 
                     by.x = "end",
                     by.y = "patch")
colnames(int_patches)[4:5] <- c("xend", "yend")
int_patches <- merge(int_patches, 
                     centroids[,c("patch", "long", "lat")], 
                     by.x = "start",
                     by.y = "patch")
colnames(int_patches)[6:7] <- c("x", "y")

# Add diff in coordinates (for calculating midpoint)
int_patches$xdiff <- int_patches$xend - int_patches$x
int_patches$ydiff <- int_patches$yend - int_patches$y

# Sort factor levels
centroids$patch <- factor(centroids$patch,
                          levels = paste(centroids$patch) %>% 
                              as.numeric() %>% 
                              sort())
int_patches$abs_start <- factor(int_patches$abs_start,
                                levels = sort(int_patches$abs_start) %>%
                                    .[!(duplicated(.))])

patch_pal <-c("#fc7b20",
              "#004ac3",
              "#6ac02a",
              "#8b3fc5",
              "#dea700",
              "#777aff",
              "#8e7200",
              "#d329ab",
              "#01af74",
              "#f32896",
              "#79da95",
              "#c6002d",
              "#01b9b4",
              "#a4084d",
              "#ccca6a",
              "#5c4398",
              "#bccd8c",
              "#006297",
              "#ff825d",
              "#c1b0ff",
              "#a14e00",
              "#744268",
              "#3b5b1f",
              "#ff88a4",
              "#75592d")

# Merge results of connectivity analysis
temp_dat$patch <- as.factor(temp_dat$patch)
patches_sub <- merge(patches_sub, temp_dat, by = "patch", all.x = TRUE)
```

```{r, echo = FALSE, include = FALSE}
p3a <-
    ggplot()+
    # Patch outlines
    geom_polygon(data = patches_sub, 
                 aes(x = long, y = lat, 
                     fill = ctemp,
                     group = group),
                 alpha = 1) +
    geom_polygon(data = patches_sub_outline, 
                 aes(x = long, y = lat,
                     group = group),
                 alpha = 0,
                 colour = "grey40",
                 size = 0.05) +
    # Patch connections
    geom_segment(data = int_patches,
                 aes(x = x - 1000, xend = xend - 1000,
                     y = y - 5500, yend = yend - 5500,
                     colour = abs_start),
                 size = 0.7) +
    # Patch connection arrows
    geom_segment(data = int_patches,
                 aes(x = x - 1000, xend = x - 1000 + (xdiff / 2),
                     y = y - 5500, yend = y - 5500 + (ydiff / 2),
                     colour = abs_start),
                 arrow = arrow(length = unit(3, "mm"),
                               angle = 30,
                               ends = "last"),
                 size = 0.7) +
    # Patch centroids
    geom_point(data = centroids, 
               aes(x = long, y = lat,
                   group = group,
                   colour = patch),
               size = 6) +
    geom_point(data = centroids, 
               aes(x = long, y = lat,
                   group = group),
               size = 4.5,
               colour = "white") +
    # Patch labels
    geom_text_repel(data = centroids, 
                    aes(x = long, y = lat, 
                        label = patch,
                        # colour = patch,
                        group = group),
                    fontface = "bold",
                    size = 2,
                    force=2,
                    segment.size= 0.2,
                    min.segment.length = unit(0, "lines"),
                    point.padding = unit(0, "lines"))+
    # geom_text(data = centroids, 
    #           aes(x = long, y = lat,
    #               group = group,
    #               label = patch),
    #           size = 2,
    #           colour = "black") +
    # # Bounding box
    # geom_rect(data = sub_extent,
    #           aes(xmin = xmin,
    #               xmax = xmax,
    #               ymin = ymin,
    #               ymax = ymax),
    #           colour = "black",
    #           alpha = 0) +
    theme_void() +
    theme(legend.title = element_text(size = text_size),
          legend.text = element_text(size = text_size),
          legend.box.spacing = unit(0,"cm"),
          legend.box.margin = margin(0,0,0,0),
          legend.position = "right") +
    coord_equal(ratio=1) +
    scale_fill_gradient(low = "black",
                        high = "grey90",
                        name = paste("Current\ntemperature\n(", "\U00B0","C)",sep="")) +
    scale_colour_manual(name = "Patch ID", 
                        values = patch_pal,
                        guide = FALSE) +
    guides(fill = guide_colourbar(title.position = "top"))

p3b <-
    ggplot()+
    # Patch outlines
    geom_polygon(data = patches_sub, 
                 aes(x = long, y = lat, 
                     fill = clim_conn,
                     group = group),
                 alpha = 1) +
    geom_polygon(data = patches_sub_outline, 
                 aes(x = long, y = lat,
                     group = group),
                 alpha = 0,
                 colour = "grey40",
                 size = 0.05) +
    theme_void() +
    theme(legend.title = element_text(size = text_size),
          legend.text = element_text(size = text_size),
          legend.box.spacing = unit(0,"cm"),
          legend.box.margin = margin(0,0,0,0),
          legend.position = "right") +
    coord_equal(ratio=1) +
    scale_fill_viridis(option = "A",
                       name = paste("Climate\nconnectivity\n(", "\U00B0","C)",sep=""))

```

(ref:cap-D-3) Pathways from origin to destination patches (a) and climate connectivity across all patches (b). In panel (a), patch shading corresponds to current mean annual temperature (&deg;C), from cooler (black) to hotter (light grey). Circles indicate patch centroids, the numbers inside correspond to the patch identity (as in Tables \ref{tab:tab-D-1}, \ref{tab:tab-D-2} and \ref{tab:tab-D-3}) and the arrows between indicate the direction of travel from hotter to cooler patches. In panel (b), patch shading corresponds to climate connectivity (&deg;C), measured as the current temperature of the origin patch minus the future temperature of the destination patch. All values here are negative, indicating that existing forest cover would fail to facilitate range shifts to an analogous future climate.

```{r fig-D-3, fig.cap = "(ref:cap-D-3)", echo = FALSE}
plot_grid(p3a, p3b, 
          align = "hv",
          ncol = 2, 
          labels = c("(a)", "(b)"), 
          label_size = lab_size)
```

```{r tab-D-2, echo=FALSE, results='asis'}
# td2 <- kable(temp_dat, format = "latex", booktabs = TRUE)
# 
# cat(c("\\begin{table}[!htb]",
#     td2,
# "\\caption{(\\#tab:tab-D-2) The results dataframe with final destination patches, final temperatures and climate connectivity for each origin patch.}
# \\end{table}"
# ))
```

\begin{table}[!htb] 
\begin{center}
\begin{tabular}{lrrrrlrr}
\toprule
patch & temp & ftemp & dest & dest\_temp & inter\_patch & dest\_ftemp & clim\_conn\\
\midrule
12 & 22.0 & 25.0 & 12 & 22.0 & NA & 25.0 & -3.0\\
43 & 22.7 & 26.0 & 43 & 22.7 & NA & 26.0 & -3.3\\
45 & 22.6 & 25.8 & 45 & 22.6 & NA & 25.8 & -3.2\\
46 & 22.6 & 25.7 & 46 & 22.6 & NA & 25.7 & -3.1\\
48 & 22.6 & 25.8 & 48 & 22.6 & NA & 25.8 & -3.2\\
\addlinespace
51 & 22.7 & 25.8 & 51 & 22.7 & NA & 25.8 & -3.1\\
52 & 22.6 & 25.8 & 52 & 22.6 & NA & 25.8 & -3.2\\
53 & 22.5 & 25.6 & 12 & 22.0 & 12 & 25.0 & -2.5\\
55 & 22.6 & 25.8 & 55 & 22.6 & NA & 25.8 & -3.2\\
58 & 22.5 & 25.5 & 58 & 22.5 & NA & 25.5 & -3.0\\
\addlinespace
104 & 23.0 & 26.1 & 12 & 22.0 & 53;12 & 25.0 & -2.0\\
106 & 23.1 & 26.2 & 12 & 22.0 & 104;53;12 & 25.0 & -1.9\\
107 & 22.9 & 26.5 & 107 & 22.9 & NA & 26.5 & -3.6\\
108 & 22.9 & 26.1 & 43 & 22.7 & 43 & 26.0 & -3.1\\
111 & 22.9 & 26.0 & 45 & 22.6 & 45 & 25.8 & -2.9\\
\addlinespace
115 & 23.0 & 26.1 & 48 & 22.6 & 48 & 25.8 & -2.8\\
116 & 23.1 & 26.5 & 116 & 23.1 & NA & 26.5 & -3.4\\
119 & 23.0 & 26.1 & 119 & 23.0 & NA & 26.1 & -3.1\\
127 & 23.0 & 25.9 & 12 & 22.0 & 53;12 & 25.0 & -2.0\\
135 & 22.8 & 25.9 & 12 & 22.0 & 53;12 & 25.0 & -2.2\\
\addlinespace
224 & 23.5 & 26.6 & 12 & 22.0 & 53;12 & 25.0 & -1.5\\
231 & 23.6 & 26.9 & 231 & 23.6 & NA & 26.9 & -3.3\\
242 & 23.5 & 26.5 & 12 & 22.0 & 104;53;12 & 25.0 & -1.5\\
266 & 23.3 & 26.4 & 12 & 22.0 & 104;53;12 & 25.0 & -1.7\\
387 & 24.0 & 27.1 & 12 & 22.0 & 104;53;12 & 25.0 & -1.0\\
\bottomrule
\end{tabular} 
\caption{(\#tab:tab-D-2) The results dataframe with final destination patches, final temperatures and climate connectivity for each origin patch.}
\end{center}
\end{table}

```{r tab-D-3, echo=FALSE, results='asis'}
# td3 <- kable(running, format = "latex", booktabs = TRUE)
# 
# cat(c("\\begin{table}[!htb]
#     \\caption{(\\#tab:tab-D-3) The `running` dataframe, after updating with each iteration through unique temperatures. Note the repeated appearance of patch 12, which is a common final destination patch.}",
#     td3,
# "\\end{table}"
# ))
```

\begin{table}[!htb]
\begin{center}
\begin{tabular}{rr}
\toprule
patch & temp\\
\midrule
12 & 22.0\\
43 & 22.7\\
45 & 22.6\\
46 & 22.6\\
48 & 22.6\\
51 & 22.7\\
52 & 22.6\\
12 & 22.0\\
55 & 22.6\\
58 & 22.5\\
12 & 22.0\\
12 & 22.0\\
107 & 22.9\\
43 & 22.7\\
45 & 22.6\\
48 & 22.6\\
116 & 23.1\\
119 & 23.0\\
12 & 22.0\\
12 & 22.0\\
12 & 22.0\\
231 & 23.6\\
12 & 22.0\\
12 & 22.0\\
12 & 22.0\\
\bottomrule
\end{tabular}
\end{center}
\caption{(\#tab:tab-D-3) The \textmyfont{running} dataframe, after updating with each iteration through unique temperatures. Note the repeated appearance of patch 12, which is a common final destination patch.}
\end{table}

\newpage
\blandscape

## Supplementary Figures

```{r fig-D-10-prep}
p1a <-
    ggplot() +
    geom_polygon(data = boundary,
                 aes(x = long,
                     y = lat,
                     group = group),
                 fill = "grey20") +
    # Line to delineate W/E hemisphere
    geom_vline(data = oceania_labs,
               aes(xintercept = vline),
               linetype = "dashed",
               size = 0.2,
               colour = "grey20") +
    # Line to delineate N/S hemisphere
    geom_hline(data = oceania_labs,
               aes(yintercept = hline),
               linetype = "dashed",
               size = 0.2,
               colour = "grey20")+
    # Oceania labels
    geom_text(data = oceania_labs,
              aes(x = long,
                  y = lat,
                  label = lab),
              size = 2) +
    # Cc polygons
    geom_polygon(data = patches,
                 aes(x = long,
                     y = lat,
                     group = group,
                     fill = cc)) +
    # Vulnerability mask
    geom_holygon(data = vuln_mask,
                 aes(x = long,
                     y = lat,
                     group = group),
                 alpha = 0.9,
                 fill = "grey") +
    # # Vulnerability overlay
    # geom_holygon(data = vuln,
    #              aes(x = long,
    #                  y = lat,
    #                  group = group),
    #              alpha = 0,
    #              fill = cbpal2[1],
    #              colour = cbpal2[1],
    #              size = 0.01) +
    facet_wrap( ~ realm,
                scales = "free",
                nrow = 1) +
    theme_bw() +
    ylab("2012") +
    theme(axis.text = element_blank(),
          axis.title.x = element_blank(),
          axis.title.y = element_text(size = title_size),
          axis.ticks = element_blank(),
          plot.margin = margin(1, 2, 1, 2),
          panel.background = element_rect(fill = "darkseagreen3"),
          panel.grid = element_blank(),
          panel.spacing.x = unit(-0.2, units = "lines"),
          panel.spacing.y = unit(0, units = "lines"),
          strip.background = element_blank(),
          strip.text = element_text(size = title_size,
                                    hjust = 0.5),
          legend.text = element_text(size = text_size),
          legend.title = element_text(size = title_size),
          legend.title.align=0.5,
          legend.box.spacing = unit(0,"cm"),
          legend.position = "bottom") +
    # scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand = c(0.010, 0)) +
    # coord_equal(ratio=1) +
    scale_fill_gradient2(low = "red4",
                         mid = "beige",
                         high = "dodgerblue", 
                         breaks = seq(-6, 6, 2),
                         # limits = c(-4,8)
                         NULL) +
    guides(fill = guide_colourbar(raster = FALSE,
                                  barheight = unit(3, units = "mm"),
                                  barwidth = unit(4, units = "cm"),
                                  # direction = "horizontal",
                                  # title.hjust = 0.5,
                                  title.position = "top",
                                  title = expression("Climate connectivity ("*degree*"C)")))

p1b <-
    ggplot() +
    # Realms
    geom_polygon(data = boundary,
                 aes(x = long,
                     y = lat,
                     group = group),
                 fill = "grey20") +
    # Line to delineate W/E hemisphere
    geom_vline(data = oceania_labs,
               aes(xintercept = vline),
               linetype = "dashed",
               size = 0.2,
               colour = "grey20") +
    # Line to delineate N/S hemisphere
    geom_hline(data = oceania_labs,
               aes(yintercept = hline),
               linetype = "dashed",
               size = 0.2,
               colour = "grey20")+
    # Oceania labels
    geom_text(data = oceania_labs,
              aes(x = long,
                  y = lat,
                  label = lab),
              size = 2) +
    # Ccc polygons
    geom_polygon(data = ccc_polys,
                 aes(x = long,
                     y = lat,
                     group = group,
                     fill = cc_change)) +
    # Vulnerability mask
    geom_polygon(data = vuln_mask,
                 aes(x = long,
                     y = lat,
                     group = group),
                 alpha = 0.9,
                 fill = "grey") +
    # # Vulnerability overlay
    # geom_polygon(data = vuln,
    #              aes(x = long,
    #                  y = lat,
    #                  group = group),
    #              alpha = 0,
    #              fill = cbpal2[1],
    #              colour = cbpal2[1],
    #              size = 0.01) +
    facet_wrap( ~ realm,
                scales = "free",
                nrow = 1) +
    theme_bw() +
    ylab("2012 - 2000") +
    theme(axis.text = element_blank(),
          axis.title.x = element_blank(),
          axis.title.y = element_text(size = title_size),
          axis.ticks = element_blank(),
          plot.margin = margin(1, 2, 1, 2),
          panel.background = element_rect(fill = "darkseagreen3"),
          panel.grid = element_blank(),
          panel.spacing.x = unit(-0.2, units = "lines"),
          panel.spacing.y = unit(0, units = "lines"),
          strip.background = element_blank(),
          strip.text = element_text(size = title_size,
                                    hjust = 0.5),
          legend.text = element_text(size = text_size),
          legend.title = element_text(size = title_size),
          legend.title.align=0.5,
          legend.box.spacing = unit(0,"cm"),
          legend.position = "bottom") +
    # scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand = c(0.010, 0)) +
    # coord_equal(ratio=1) +
    scale_fill_gradient2(low = "red4",
                         mid = "beige",
                         high = "dodgerblue",
                         breaks = seq(-10, 10, 5),
                         limits = c(-10,10),
                         NULL) +
    guides(fill = guide_colourbar(raster = FALSE,
                                  barheight = unit(3, units = "mm"),
                                  barwidth = unit(4, units = "cm"),
                                  # direction = "horizontal",
                                  # title.hjust = 0.5,
                                  title.position = "top",
                                  title = expression(Delta~"Climate connectivity ("*degree*"C)")))
p1 <-
    plot_grid(p1a, p1b, 
              nrow = 2, ncol = 1,
              align = "hv", 
              labels = c("(a)", "(b)"), 
              label_size = lab_size)
```


(ref:cap-D-10) Climate connectivity in 2012 (a) and change in climate connectivity from 2000 to 2012 (b) overlaid with areas of high climate vulnerability for mammals derived from @pacifici_framework_2018 (regions outside of these areas are masked in grey). We defined high vulnerability areas as those where more than 50% of mammal species had a negative predicted response to climate change. As in [Chapter 5](#ch5) (\autoref{fig:fig-5-1}), positive values (blue) indicate successful climate connectivity in panel (a), or a gain of connectivity in panel (b). Negative values (red) indicate unsuccessful climate connectivity in panel (a), or a loss of connectivity in panel (b). To aid visualisation we have shifted land masses in Oceania.

```{r fig-D-10, fig.cap= "(ref:cap-D-10)", fig.width = 23/2.54, fig.height = 10/2.54}
p1
```

\newpage

```{r fig-D-11-prep}
p2a <-
    ggplot() +
    geom_polygon(data = boundary,
                 aes(x = long,
                     y = lat,
                     group = group),
                 fill = "grey20") +
    # Line to delineate W/E hemisphere
    geom_vline(data = oceania_labs,
               aes(xintercept = vline),
               linetype = "dashed",
               size = 0.2,
               colour = "grey20") +
    # Line to delineate N/S hemisphere
    geom_hline(data = oceania_labs,
               aes(yintercept = hline),
               linetype = "dashed",
               size = 0.2,
               colour = "grey20")+
    # Oceania labels
    geom_text(data = oceania_labs,
              aes(x = long,
                  y = lat,
                  label = lab),
              size = 2) +
    # Cc polygons
    geom_polygon(data = patches,
                 aes(x = long,
                     y = lat,
                     group = group,
                     fill = cc)) +
    # KBA mask
    geom_holygon(data = kba_mask,
                 aes(x = long,
                     y = lat,
                     group = group),
                 alpha = 0.9,
                 fill = "grey") +
    # # KBA overlay
    # geom_holygon(data = kba,
    #              aes(x = long,
    #                  y = lat,
    #                  group = group),
    #              alpha = 0,
    #              fill = cbpal2[1],
    #              colour = cbpal2[1],
    #              size = 0.01) +
    facet_wrap( ~ realm,
                scales = "free",
                nrow = 1) +
    theme_bw() +
    ylab("2012") +
    theme(axis.text = element_blank(),
          axis.title.x = element_blank(),
          axis.title.y = element_text(size = title_size),
          axis.ticks = element_blank(),
          plot.margin = margin(1, 2, 1, 2),
          panel.background = element_rect(fill = "darkseagreen3"),
          panel.grid = element_blank(),
          panel.spacing.x = unit(-0.2, units = "lines"),
          panel.spacing.y = unit(0, units = "lines"),
          strip.background = element_blank(),
          strip.text = element_text(size = title_size,
                                    hjust = 0.5),
          legend.text = element_text(size = text_size),
          legend.title = element_text(size = title_size),
          legend.title.align=0.5,
          legend.box.spacing = unit(0,"cm"),
          legend.position = "bottom") +
    # scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand = c(0.010, 0)) +
    # coord_equal(ratio=1) +
    scale_fill_gradient2(low = "red4",
                         mid = "beige",
                         high = "dodgerblue", 
                         breaks = seq(-6, 6, 2),
                         # limits = c(-4,8)
                         NULL) +
    guides(fill = guide_colourbar(raster = FALSE,
                                  barheight = unit(3, units = "mm"),
                                  barwidth = unit(4, units = "cm"),
                                  # direction = "horizontal",
                                  # title.hjust = 0.5,
                                  title.position = "top",
                                  title = expression("Climate connectivity ("*degree*"C)")))

p2b <-
    ggplot() +
    # Realms
    geom_polygon(data = boundary,
                 aes(x = long,
                     y = lat,
                     group = group),
                 fill = "grey20") +
    # Line to delineate W/E hemisphere
    geom_vline(data = oceania_labs,
               aes(xintercept = vline),
               linetype = "dashed",
               size = 0.2,
               colour = "grey20") +
    # Line to delineate N/S hemisphere
    geom_hline(data = oceania_labs,
               aes(yintercept = hline),
               linetype = "dashed",
               size = 0.2,
               colour = "grey20")+
    # Oceania labels
    geom_text(data = oceania_labs,
              aes(x = long,
                  y = lat,
                  label = lab),
              size = 2) +
    # Ccc polygons
    geom_polygon(data = ccc_polys,
                 aes(x = long,
                     y = lat,
                     group = group,
                     fill = cc_change)) +
    # KBA mask
    geom_holygon(data = kba_mask,
                 aes(x = long,
                     y = lat,
                     group = group),
                 alpha = 0.9,
                 fill = "grey") +
    # # KBA overlay
    # geom_holygon(data = kba,
    #              aes(x = long,
    #                  y = lat,
    #                  group = group),
    #              alpha = 0,
    #              fill = cbpal2[1],
    #              colour = cbpal2[1],
    #              size = 0.01) +
    facet_wrap( ~ realm,
                scales = "free",
                nrow = 1) +
    theme_bw() +
    ylab("2012 - 2000") +
    theme(axis.text = element_blank(),
          axis.title.x = element_blank(),
          axis.title.y = element_text(size = title_size),
          axis.ticks = element_blank(),
          plot.margin = margin(1, 2, 1, 2),
          panel.background = element_rect(fill = "darkseagreen3"),
          panel.grid = element_blank(),
          panel.spacing.x = unit(-0.2, units = "lines"),
          panel.spacing.y = unit(0, units = "lines"),
          strip.background = element_blank(),
          strip.text = element_text(size = title_size,
                                    hjust = 0.5),
          legend.text = element_text(size = text_size),
          legend.title = element_text(size = title_size),
          legend.title.align=0.5,
          legend.box.spacing = unit(0,"cm"),
          legend.position = "bottom") +
    # scale_x_continuous(expand = c(0, 0))+
    scale_y_continuous(expand = c(0.010, 0)) +
    # coord_equal(ratio=1) +
    scale_fill_gradient2(low = "red4",
                         mid = "beige",
                         high = "dodgerblue",
                         breaks = seq(-10, 10, 5),
                         limits = c(-10,10),
                         NULL) +
    guides(fill = guide_colourbar(raster = FALSE,
                                  barheight = unit(3, units = "mm"),
                                  barwidth = unit(4, units = "cm"),
                                  # direction = "horizontal",
                                  # title.hjust = 0.5,
                                  title.position = "top",
                                  title = expression(Delta~"Climate connectivity ("*degree*"C)")))
p2 <-
    plot_grid(p2a, p2b, 
              nrow = 2, ncol = 1,
              align = "hv", 
              labels = c("(a)", "(b)"), 
              label_size = lab_size)
```

(ref:cap-D-11) Climate connectivity in 2012 (a) and change in climate connectivity from 2000 to 2012 (b) overlaid with Key Biodiversity Areas from BirdLife International (regions outside of these areas are masked in grey). As in [Chapter 5](#ch5) (\autoref{fig:fig-5-1}), positive values (blue) indicate successful climate connectivity in panel (a), or a gain of connectivity in panel (b). Negative values (red) indicate unsuccessful climate connectivity in panel (a), or a loss of connectivity in panel (b). To aid visualisation we have shifted land masses in Oceania.

```{r fig-D-11, fig.cap= "(ref:cap-D-11)", fig.width = 25/2.54, fig.height = 11/2.54}
p2
```

\elandscape
\newpage
\clearpage
\fancyhead[R]{Bibliography}
\addcontentsline{toc}{chapter}{Bibliography}
